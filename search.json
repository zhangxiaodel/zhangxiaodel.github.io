[{"title":"HashedDict","url":"/2020/07/24/HashedDict/","content":"<h4 id=\"自定义字典\"><a href=\"#自定义字典\" class=\"headerlink\" title=\"自定义字典\"></a>自定义字典</h4><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashedDict</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        自定义hashtable</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, size=<span class=\"number\">10</span></span>):</span></span><br><span class=\"line\">        self.hash_list = [<span class=\"built_in\">list</span>() <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(size)]</span><br><span class=\"line\">        self.size = size</span><br><span class=\"line\">        self.length = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setitem__</span>(<span class=\"params\">self, key, value</span>):</span></span><br><span class=\"line\">        hash_key = <span class=\"built_in\">hash</span>(key) % self.size</span><br><span class=\"line\">        sub_list = self.hash_list[hash_key]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sub_list:</span><br><span class=\"line\">        \t\t<span class=\"comment\"># hash冲突时使用list向后追加元素 </span></span><br><span class=\"line\">            matched=<span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> sub_list:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> item[<span class=\"number\">0</span>] == key:</span><br><span class=\"line\">                    item[<span class=\"number\">1</span>] = value</span><br><span class=\"line\">                    matched=<span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> matched:</span><br><span class=\"line\">                sub_list.append([key, value])</span><br><span class=\"line\">                self.length += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            sub_list.append([key, value])</span><br><span class=\"line\">            self.length += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span>(<span class=\"params\">self, key</span>):</span></span><br><span class=\"line\">        sub_list = self.hash_list[<span class=\"built_in\">hash</span>(key) % self.size]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sub_list:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> sub_list:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> item[<span class=\"number\">0</span>] == key:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> item[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> KeyError(key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__contains__</span>(<span class=\"params\">self, key</span>):</span></span><br><span class=\"line\">        sub_list = self.hash_list[<span class=\"built_in\">hash</span>(key) % self.size]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> sub_list:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> item[<span class=\"number\">0</span>] == key:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> sub_list <span class=\"keyword\">in</span> self.hash_list:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> sub_list:</span><br><span class=\"line\">                result.append(<span class=\"built_in\">str</span>(item[<span class=\"number\">0</span>] + <span class=\"string\">&quot;:&quot;</span> + <span class=\"built_in\">str</span>(item[<span class=\"number\">1</span>])))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;,&quot;</span>.join(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">items</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> sub_list <span class=\"keyword\">in</span> self.hash_list:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> sub_list:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> innitem <span class=\"keyword\">in</span> sub_list:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> innitem</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">values</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> sub_list <span class=\"keyword\">in</span> self.hash_list:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> sub_list:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> innitem <span class=\"keyword\">in</span> sub_list:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> innitem[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__len__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.length</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.__repr__()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h6><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_it</span>():</span></span><br><span class=\"line\">    print(<span class=\"string\">&#x27;test begin&#x27;</span>)</span><br><span class=\"line\">    dd = HashedDict()</span><br><span class=\"line\">    dd[<span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    dd[<span class=\"string\">&#x27;b&#x27;</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">    print(dd)</span><br><span class=\"line\">    print(<span class=\"built_in\">len</span>(dd))</span><br><span class=\"line\">    print(<span class=\"built_in\">repr</span>(dd))</span><br><span class=\"line\">    print(<span class=\"built_in\">list</span>(dd.items()))</span><br><span class=\"line\">    print(<span class=\"built_in\">list</span>(dd.values()))</span><br><span class=\"line\">    print(<span class=\"string\">&#x27;test end&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n","tags":["dict, hash"]},{"title":"数据导出\\导入","url":"/2019/08/11/db-1/","content":"<h3 id=\"mysqldump\"><a href=\"#mysqldump\" class=\"headerlink\" title=\"mysqldump\"></a>mysqldump</h3><ul>\n<li><p><strong>-t</strong> 只导出数据 ,不导结构 , --skip-lock-tables 不锁表</p>\n<blockquote>\n<p>mysqldump -h127.0.0.1 -P3306 -uuser -ppwd -t --skip-lock-tables  test tab1&gt;tab1.sql</p>\n</blockquote>\n</li>\n<li><p><strong>-d</strong> 只备份结构  <strong>--skip-add-drop-table</strong> 禁用drop tabe(默认会有drop table)</p>\n<blockquote>\n<p>mysqldump -hlocalhost -P3306 -uuser -ppwd -d  --skip-add-drop-table test tab1&gt; test.tab1.sql</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>整库备份</p>\n<blockquote>\n<p>mysqldump -hlocalhost -P3306 -uuser -ppwd  -B test  &gt; test.sql</p>\n</blockquote>\n</li>\n<li><p>重要参数</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-B：指定多个库，在备份文件中增加建库语句和use语句</span><br><span class=\"line\">--compact：去掉备份文件中的注释，适合调试，生产场景不用</span><br><span class=\"line\">-A：备份所有库</span><br><span class=\"line\">-F：刷新binlog日志</span><br><span class=\"line\">--master-data：在备份文件中增加binlog日志文件名及对应的位置点</span><br><span class=\"line\">-x  --lock-all-tables：锁表</span><br><span class=\"line\">-l：只读锁表</span><br><span class=\"line\">-d：只备份表结构</span><br><span class=\"line\">-t：只备份数据</span><br><span class=\"line\">--single-transaction：适合innodb事务数据库的备份</span><br><span class=\"line\">   InnoDB表在备份时，通常启用选项--single-transaction来保证备份的一致性，原理是设定本次会话的隔离级别为Repeatable read，来保证本次会话（也就是dump）时，不会看到其它会话已经提交了的数据。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"导入备份数据\"><a href=\"#导入备份数据\" class=\"headerlink\" title=\"导入备份数据\"></a>导入备份数据</h3></li>\n<li><p>命令行导入</p>\n<blockquote>\n<p>mysql -hlocalhost -P3306 -uuser -ppwd test  &lt; test.test.sql</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><ul>\n<li>命令行查询<blockquote>\n<p>mysql -hlocalhost -P3306 -uroot -p123456  -e &quot;use test; set names utf8; select * from img_library limit 10;&quot; &gt; tmp.xls</p>\n</blockquote>\n</li>\n</ul>\n","tags":["数据库,备份"]},{"title":"pyenv python2.7/3.6 共存/切换实践","url":"/2019/08/28/env_py/","content":"<p>在docker(python27) 环境中</p>\n<blockquote>\n<p>参考 <a href=\"https://www.jianshu.com/p/3e93311fe6cb\">简书-pyenv 让 python 版本完美切换</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/pyenv/pyenv-virtualenv\">更多见github/pyenv-virtualenv</a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker search python</span><br><span class=\"line\">&gt;&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\">docker pull centos/python-27-centos7</span><br><span class=\"line\"></span><br><span class=\"line\">docker images</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--运行docker 环境 --&gt;</span><br><span class=\"line\">docker run -i -t centos/python-27-centos7 /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--继续配置环境...  --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--首先把项目克隆下来，放在家目录下的隐藏文件夹中：.pyenv--&gt;</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--配置环境变量 ,依次执行如下命令--&gt;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&#x27;if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval &quot;$(pyenv init -)&quot;\\nfi&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--安装 pyenv-virtualenv--&gt;</span><br><span class=\"line\">&lt;!--插件克隆在刚才已经安装完毕的 pyenv 的 plugins 文件夹中--&gt;</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--开始使用 pyenv--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">pyenv version/versions(查看本地安装的python版本)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- pyenv install 敲tag ,可列出支持的版本 --&gt;</span><br><span class=\"line\">pyenv install 3.6.8</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--如果失败,可安装依赖的包--&gt;</span><br><span class=\"line\">sudo yum install gcc zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel openssl-devel tk-devel libffi-devel</span><br><span class=\"line\"></span><br><span class=\"line\">pyenv versions</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--pyenv 托管 python 版本，virtualenv 使用 python 版本--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--创建虚拟环境--&gt;</span><br><span class=\"line\">pyenv virtualenv 3.6.8 venv3.6.8</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--激活, 在docker中,发现activate 并不能成功切换环境 ,最终使用 <span class=\"built_in\">local</span> 可以完成切换 --&gt;</span><br><span class=\"line\">&lt;!--<span class=\"built_in\">local</span> 命令,会在目标文件夹中生成 .python-version 文件, 文件内容是 venv3.6.8, 这样只要进入目录就会自动激活环境 --&gt;</span><br><span class=\"line\">pyenv activate venv3.6.8</span><br><span class=\"line\">pyenv <span class=\"built_in\">local</span>  venv3.6.8</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--查看pip 安装目录 --&gt;</span><br><span class=\"line\">pip --version</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--更新pyenv --&gt;</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.pyenv 或者 <span class=\"built_in\">cd</span> $(pyenv root)</span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--卸载 pyenv--&gt;</span><br><span class=\"line\">1. 要删除环境变量</span><br><span class=\"line\">2. rm -rf ~/.pyenv</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--继续配置环境..., 在另一个窗口中将当前docker 保存成镜像, 方便以后使用  --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">docker commit 8bacc8c47607(docker ps.pid) centos_pyenv_368</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["pyenv, python3.6 ,虚拟环境"]},{"title":"Flask 请求处理流程","url":"/2019/09/05/flask_request_process123/","content":"<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sockerserver.py.BaseServer.server_forever._handle_request_noblock()</span><br><span class=\"line\">           .process_request.finish_request()</span><br><span class=\"line\">           .BaseRequestHandle.__init__().handle()</span><br><span class=\"line\">            werkzeug.serving.py.WSGIRequestHandler.BaseHTTPRequestHandler.handle().handle_one_request().parse_requests().run_wsgi()</span><br><span class=\"line\">                                                         .execute(app)</span><br><span class=\"line\">            werkzeug.debug.DebuggedApplication.__call__().Request(environ).response(environ, start_response)</span><br><span class=\"line\">                            werkzeug.serving.execute(<span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> application_iter:).__call__().run_wsgi()</span><br><span class=\"line\">                                            .wsgi_app().request_contex()</span><br><span class=\"line\">                                flask.ctx.py.push().app_ctx.push(**match_request会将当前请求的地址request.url 用正则解析成路由配置表中的数据及参数 **).session_interface.open_session(app, request)</span><br><span class=\"line\">                                flask.full_dispatch_request().preprocess_request()</span><br><span class=\"line\">                                                        .dispatch_request().view_functions(<span class=\"string\">&#x27;业务处理&#x27;</span>)</span><br><span class=\"line\">                                    .finalize_request(rv).make_response()</span><br><span class=\"line\">                                                    .process_response(response).session_interface.save_session()</span><br><span class=\"line\"></span><br><span class=\"line\">                            werkzeug.wsgi_app().<span class=\"keyword\">return</span> response()</span><br><span class=\"line\">                                            .ctx.auto_pop(error)</span><br><span class=\"line\"></span><br><span class=\"line\">            .shutdown_request(request)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/flask-werkzuge-123.png\" loading=\"lazy\"></p>\n","tags":["flask, request"]},{"title":"第一次为开源项目贡献pull request ,并被作者采用","url":"/2020/12/08/first-pr/","content":"<h4 id=\"第一次为开源项目贡献pull-request-并被作者采用\"><a href=\"#第一次为开源项目贡献pull-request-并被作者采用\" class=\"headerlink\" title=\"第一次为开源项目贡献pull request ,并被作者采用\"></a>第一次为开源项目贡献pull request ,并被作者采用</h4><p>项目地址: <a href=\"https://github.com/Shelnutt2/db2struct/\">Shelnutt2/db2struct</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    在golang的学习实践中用到了 ORM框架 GORM,  是一个优秀的开源框架, star人数很高, 在编写与之对应的mode对象时, 就自然遇到了由mysql数据表生成model的需求,</span><br><span class=\"line\">在github上找到这 Shelnutt2&#x2F;db2struct 这个开源项目, 太感谢作者了, 解决了这一痛点问题.</span><br><span class=\"line\">    随着对代码的深入,发现db2struct 还可以有两点改进, 所以有了此次的修改,以及pull request  , 分两次解决了如下的改进, </span><br><span class=\"line\">    作者也有nice,并最终合并的pr .</span><br><span class=\"line\">    1 由table生成的model中的字段默认是按字段名排序的, 我们更希望的是以数据表ddl 的顺序为准 </span><br><span class=\"line\">    2 model 的tag 并未指定column ,这样在遇到非默认字段名规则时会关联失败 </span><br><span class=\"line\">    3 还有一个小改进,就是把ddl的comment 添加到model中</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<p><img src=\"/images/git_pullrequest_20201208_30.png\" alt=\"pr preview\" loading=\"lazy\"></p>\n","tags":["pr, pull request"]},{"title":"celery分布式异步任务队列","url":"/2019/10/18/celery-123/","content":"<p>celery是一个基于分布消息传递的异步任务队列.它一定需要建立在一个分布的消息传递机制上，这个消息传递机制就是celery文档里常说的broker。</p>\n<p>celery隐藏了rabbitmq接口的实现细节，既充当了publisher（client）又充当了consumer (worker)的角色。</p>\n<p>&#39;&#39;&#39;思考一下，如果我们用rabbitmq自己实现任务队列，有一天我们不想用rabbit了怎么办？我们换个思维，如果没有celery，让你自己设计一个异步任务队列你怎么做。首先，要有一个发起任务的client，选定一定保存任务信息的媒介，由一个worker去一直监听这个信息媒介，这个worker最好是多进程的，另外可以兼容尽可能多得信息媒介。好吧，这个不就是celery所做的事儿么，celery兼容多个broker，既是任务发起者又是执行者，另外支持多进程…还有好多通用功能考虑。<br>&#39;&#39;&#39;</p>\n<p>假设项目的目录结构是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">task--</span><br><span class=\"line\">    --celeryapp</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动消费者</span></span><br><span class=\"line\">celery -A task.celeryapp worker -l info  -c 5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费者异常退出后 ,正常情况下重启后会继续消息已经积压的任务, 看情况要将过期任务清除</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动web监控</span></span><br><span class=\"line\">celery -A task.celeryapp flower -l info --basic_auth=user1:111111</span><br><span class=\"line\">flower -A task.celeryapp --port=8091</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动Beat进程,定时任务, 定时将任务发送到broker</span></span><br><span class=\"line\">celery beat -A task.celeryapp -l info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同时启动 消费者和定时任务</span></span><br><span class=\"line\">celery -B -A task.celeryapp  worker -l info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以在当前目录的上一层来启动 需指定 package.celeryapp</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动 定时任务和消费者</span></span><br><span class=\"line\">celery multi restart w1 -B -A task.celeryapp -l info</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># celery status -A celery_task</span></span><br><span class=\"line\">celery -A task.celeryapp inspect stats</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># celery.send_task()这个方法解决了producer和consumer的网路拓扑传递数据问题。</span></span><br><span class=\"line\">celery=Celery()</span><br><span class=\"line\">celery.config_from_object(<span class=\"string\">&#x27;task.celeryconfig&#x27;</span>)</span><br><span class=\"line\">celery.send_task(<span class=\"string\">&#x27;tq.tasks.test&#x27;</span>, (<span class=\"string\">&quot;hello world&quot;</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一般调用方法</span></span><br><span class=\"line\">from task.tasks import <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> test.delay(<span class=\"string\">&#x27;param from invoke &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止正在执行的任务</span></span><br><span class=\"line\"><span class=\"comment\"># 使用方法名调用 可以避免依赖方法的实现代码</span></span><br><span class=\"line\">...</span><br><span class=\"line\">celery.config_from_object(<span class=\"string\">&#x27;task.celeryconfig&#x27;</span>)</span><br><span class=\"line\">from celery.task.control import revoke</span><br><span class=\"line\">revoke(<span class=\"string\">&#x27;aac00b9c-f701-4a21-bed4-53a8b865a39a&#x27;</span>, terminate=True)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">from celery.result import AsyncResult</span><br><span class=\"line\">res=AsyncResult(t.task_id)</span><br><span class=\"line\">res.state</span><br><span class=\"line\">&lt;!----&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">res.revoke(terminate=True)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置信息</span></span><br><span class=\"line\">json.dumps(celeryapp.control.inspect().conf(), indent=2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 已注册的任务列表(得到的列表可以在web页面上做处理, 文件手动触发)</span></span><br><span class=\"line\">celeryapp.control.inspect().registered_tasks()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 任务执行情况</span></span><br><span class=\"line\">celeryapp.control.inspect().active()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 任务执行情况</span></span><br><span class=\"line\">celeryapp.control.inspect().stats()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在使用flower时遇到  &#39;stats&#39; inspect method failed , 最终通安装指定版本的kombu 解决 4.5.0</span><br><span class=\"line\">pipenv install kombu&#x3D;&#x3D;4.5.0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","tags":["celery ,  flower , redis"]},{"title":"利用有缓冲通道写满时阻塞的特点来控制协程的并发数量","url":"/2020/12/16/go1-goroutinepool/","content":"<h4 id=\"利用有缓冲通道写满时阻塞的特点来控制协程的并发数量\"><a href=\"#利用有缓冲通道写满时阻塞的特点来控制协程的并发数量\" class=\"headerlink\" title=\"利用有缓冲通道写满时阻塞的特点来控制协程的并发数量\"></a>利用有缓冲通道写满时阻塞的特点来控制协程的并发数量</h4><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LineGraber <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//最多允许n个并发同时执行</span></span><br><span class=\"line\">\tConcurrentNum <span class=\"keyword\">int</span> <span class=\"string\">`json:&quot;concurrent_num&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(grab LineGraber)</span> <span class=\"title\">Work</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &quot;work start&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最少5个协程一起工作</span></span><br><span class=\"line\">concurrentNum := grab.ConcurrentNum</span><br><span class=\"line\"><span class=\"keyword\">if</span> concurrentNum &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    concurrentNum = <span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// sem通道容量限制了并发的协程数</span></span><br><span class=\"line\">sem := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, concurrentNum)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 准备待处理的任务列表  </span></span><br><span class=\"line\">taskLst := grab.buildTaskLst()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接口任务处理结果的通道</span></span><br><span class=\"line\">chanRespv := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(taskLst))</span><br><span class=\"line\"></span><br><span class=\"line\">total := <span class=\"built_in\">len</span>(taskLst)</span><br><span class=\"line\"><span class=\"comment\">// log info fmt.Sprintf(&quot;tasksize:%d&quot;, total) </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, key := <span class=\"keyword\">range</span> taskLst &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(taskv <span class=\"keyword\">string</span>, i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 确保 wg.Done() (与add对应), </span></span><br><span class=\"line\">   <span class=\"comment\">//     &lt;-sem, 从semchan中取出(与下面 sem&lt;- struct&#123;&#125;&#123;&#125;对应)</span></span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            wg.Done()</span><br><span class=\"line\">            &lt;-sem</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        sem &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 真实业务逻辑部分 </span></span><br><span class=\"line\">        <span class=\"comment\">// 方法中要将结果写入到chanRespv </span></span><br><span class=\"line\">        <span class=\"comment\">// log info i, taskv </span></span><br><span class=\"line\">        grab.processTask(taskv, oneproxy, chanRespv)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;(key, idx)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wg.Wait()</span><br><span class=\"line\"><span class=\"built_in\">close</span>(chanRespv)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// range 可以从已经关闭的chan 中读取原有数据, 并退出  </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> respv := <span class=\"keyword\">range</span> chanRespv &#123;</span><br><span class=\"line\">    <span class=\"comment\">// log info read from chanResp</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> respResult RespResult</span><br><span class=\"line\">    err := json.Unmarshal([]<span class=\"keyword\">byte</span>(respv), &amp;respResult)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// log error decode异常 </span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// process ... </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// log info (&quot;work done&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上方法中在 wg.Wait之后才开始接收 chanRespv ,其实还可以优化\\尽早提前处理chanRespv(可以及时读取到结果,避免所有任务完成后才读取到结果的情况), 只需新启协程在wg.Wait 之前接收处理 . </span></span><br><span class=\"line\"><span class=\"comment\">// 要增加另外一个通道, 控制完成并退出的信号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在wg.wait 之前 </span></span><br><span class=\"line\">chanSignal := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> result, ok := &lt;-limiter.resultChan:</span><br><span class=\"line\">            common.ZLogger.Info(<span class=\"string\">&quot;done&quot;</span>, zap.Any(<span class=\"string\">&quot;result&quot;</span>, result))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">                common.ZLogger.Info(<span class=\"string\">&quot;result通道关闭,退出当前goroutine&quot;</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 通知主线程,可以继续向下执行了 </span></span><br><span class=\"line\">                chanSignal&lt;- <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在程序最后添加 </span></span><br><span class=\"line\">&lt;-chanSignal</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 业务逻辑处理  </span></span><br><span class=\"line\"><span class=\"comment\">// 注意chan 类型是只可写入 chan &lt;-  string  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(grab LineGraber)</span> <span class=\"title\">processTask</span><span class=\"params\">(key <span class=\"keyword\">string</span>, proxy <span class=\"keyword\">string</span>, outchan <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\taimUrl := fmt.Sprintf(grap_base_url, key)</span><br><span class=\"line\">\trespv, err := doget... </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// log error ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//log info ... </span></span><br><span class=\"line\">\toutchan &lt;- respv</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","tags":["goroutine go pool 并发 协程"]},{"title":"自实现 Goroutine pool","url":"/2020/12/16/go2-goroutinepool-limiter/","content":"<h4 id=\"自实现-Goroutine-pool\"><a href=\"#自实现-Goroutine-pool\" class=\"headerlink\" title=\"自实现 Goroutine pool\"></a>自实现 Goroutine pool</h4><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// limiter.go </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> limiter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go.uber.org/zap&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;station.grab/src/common&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// MinimaLimit is the minimal concurrency limit</span></span><br><span class=\"line\">\tMinimaLimit = <span class=\"number\">5</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Job is an interface for add jobs.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Job <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tRun() (resp <span class=\"keyword\">string</span>, err error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// EasyLimiter object</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> EasyLimiter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsemp <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">// 控制并发的chan</span></span><br><span class=\"line\"></span><br><span class=\"line\">\twg sync.WaitGroup <span class=\"comment\">// waitGroup 用于等待协程执行完成, 并关闭通道\\清理资源</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tjobChan    <span class=\"keyword\">chan</span> Job         <span class=\"comment\">// Job 队列(实现接口即可, 解耦了任务的具体实现)</span></span><br><span class=\"line\">\tresultChan <span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125; <span class=\"comment\">// job执行结果队列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewEasyLimiter</span><span class=\"params\">(taskCount, limit <span class=\"keyword\">int</span>)</span> *<span class=\"title\">EasyLimiter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> limit &lt;= MinimaLimit &#123;</span><br><span class=\"line\">\t\tlimit = MinimaLimit</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc := &amp;EasyLimiter&#123;</span><br><span class=\"line\">\t\tsemp:       <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, limit),</span><br><span class=\"line\">\t\tresultChan: <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125;, taskCount),</span><br><span class=\"line\">\t\tjobChan:    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Job, taskCount),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建后马上就监听job队列</span></span><br><span class=\"line\">\t<span class=\"comment\">// job队列中有数据且semp队列未满 (满了会阻塞,以此来实现并发控制), 则取出job对象, 交给单独协程处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> job := <span class=\"keyword\">range</span> c.jobChan &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//c.semp &lt;- struct&#123;&#125;&#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> c.semp &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-time.After(time.Millisecond * <span class=\"number\">200</span>):</span><br><span class=\"line\">\t\t\t\tcommon.ZLogger.Info(<span class=\"string\">&quot;goroutine pool full, wait for 200 mis  &quot;</span>, zap.Int(<span class=\"string\">&quot;size&quot;</span>, <span class=\"built_in\">len</span>(c.semp)))</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ajob Job)</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t\tc.wg.Done()</span><br><span class=\"line\">\t\t\t\t\t&lt;-c.semp</span><br><span class=\"line\">\t\t\t\t&#125;()</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//common.ZLogger.Info(&quot;开始执行任务&quot;)</span></span><br><span class=\"line\">\t\t\t\tresult, err := ajob.Run()</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//common.ZLogger.Info(&quot;完成执行任务&quot;)</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tfmt.Printf(<span class=\"string\">&quot;err:%v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tc.resultChan &lt;- result</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;(job)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcommon.ZLogger.Info(<span class=\"string\">&quot;task队列关闭&quot;</span>)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *EasyLimiter)</span> <span class=\"title\">AddJob</span><span class=\"params\">(job Job)</span></span> &#123;</span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tc.jobChan &lt;- job</span><br><span class=\"line\">\t<span class=\"comment\">//common.ZLogger.Info(&quot;添加任务&quot;)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *EasyLimiter)</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭job队列 ,此时已不会再添加</span></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(c.jobChan)</span><br><span class=\"line\">\tc.wg.Wait()</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭result队列,以保证range方式读取chan 程序会正常向下执行</span></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(c.resultChan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// limiter_test.go </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> limiter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go.uber.org/zap&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;station.grab/src/common&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Max</span><span class=\"params\">(a <span class=\"keyword\">int</span>, b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"comment\">//注意参数和返回值是怎么声明的</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RandomInt</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\trand.Seed(time.Now().UnixNano())</span><br><span class=\"line\">\tv := rand.Intn(n)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v &lt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\tv = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SampleJob <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttotal <span class=\"keyword\">int</span></span><br><span class=\"line\">\tidx   <span class=\"keyword\">int</span></span><br><span class=\"line\">\tkey   <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s SampleJob)</span> <span class=\"title\">Run</span><span class=\"params\">()</span> <span class=\"params\">(resp <span class=\"keyword\">string</span>, err error)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tv := fmt.Sprintf(<span class=\"string\">&quot;job run: %d/%d, %v&quot;</span>, s.idx, s.total, s.key)</span><br><span class=\"line\">\tcommon.ZLogger.Info(v)</span><br><span class=\"line\">\t<span class=\"comment\">//time.Sleep(time.Second*time.Duration(RandomInt(5)))</span></span><br><span class=\"line\">\ttime.Sleep(time.Second * <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> v, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestLimiter_Execute</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;begin&quot;</span>)</span><br><span class=\"line\">\ttotal := <span class=\"number\">20</span></span><br><span class=\"line\">\tlimiter := NewEasyLimiter(total, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; total; i++ &#123;</span><br><span class=\"line\">\t\tlimiter.AddJob(&amp;SampleJob&#123;</span><br><span class=\"line\">\t\t\ttotal: total,</span><br><span class=\"line\">\t\t\tidx:   i,</span><br><span class=\"line\">\t\t\tkey:   <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 控制完成并退出的信号</span></span><br><span class=\"line\">\tchanSignal := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> result, ok := &lt;-limiter.resultChan:</span><br><span class=\"line\">\t\t\t\tcommon.ZLogger.Info(<span class=\"string\">&quot;read from result chan &quot;</span>, zap.Any(<span class=\"string\">&quot;result&quot;</span>, result))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t\tcommon.ZLogger.Info(<span class=\"string\">&quot;result通道关闭,退出当前goroutine&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\tchanSignal&lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlimiter.Wait()</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;-chanSignal</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestRandom</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(RandomInt(<span class=\"number\">5</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","tags":["goroutine go pool 并发 协程"]},{"title":"使用itsdangerous生成临时身份令牌","url":"/2019/08/19/flask_123/","content":"<h3 id=\"使用itsdangerous生成临时身份令牌\"><a href=\"#使用itsdangerous生成临时身份令牌\" class=\"headerlink\" title=\"使用itsdangerous生成临时身份令牌\"></a>使用itsdangerous生成临时身份令牌</h3><p>在需要身份验证的场景中,可以利用token , 主要流程是由email 向用户下发token, 用户收到邮件证明是本人, 用户点击带有token的链接地址,将token上传后后台 , 后台验证token, 从token中解析出用户信息, 完成一个完整的用户身份验证</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itsdangerous</span><br><span class=\"line\">salt=<span class=\"string\">&#x27;111&#x27;</span></span><br><span class=\"line\">t=itsdangerous.TimedJSONWebSignatureSerializer(salt, expires_in=<span class=\"number\">20</span>)</span><br><span class=\"line\">res= t.dumps(&#123;<span class=\"string\">&#x27;sid&#x27;</span>:<span class=\"string\">&#x27;flight&#x27;</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">&#x27;eyJhbGciOiJIUzI1NiIsImV4cCI6MTU2NjE5NDQwOSwiaWF0IjoxNTY2MTk0Mzg5fQ.eyJzaWQiOiJmbGlnaHQifQ.z-56NiU93Jvuus4dezdBcCmveVEBFaqCyHShJPjvgxs&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">t.loads(tes)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>&#123;<span class=\"string\">u&#x27;sid&#x27;</span>: <span class=\"string\">u&#x27;flight&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> &lt;!--过期或改变令牌的任意字符 将失败--&gt;</span><br><span class=\"line\">SignatureExpired: Signature expired</span><br><span class=\"line\">BadSignature: Signature <span class=\"string\">&#x27;GCkAmN6DEOW_oUteJStX8N93W99z_RqMcAOvINpsQd8a&#x27;</span> does <span class=\"keyword\">not</span> match</span><br></pre></td></tr></table></figure>\n\n\n\n","tags":["web, flask ,token"]},{"title":"go test","url":"/2020/12/29/go3-test/","content":"<h4 id=\"使用TestMain-或自定义Test-为测试增加前置-后置方法调用\"><a href=\"#使用TestMain-或自定义Test-为测试增加前置-后置方法调用\" class=\"headerlink\" title=\"使用TestMain 或自定义Test* 为测试增加前置\\后置方法调用\"></a>使用TestMain 或自定义Test* 为测试增加前置\\后置方法调用</h4><ul>\n<li>自定义testFun1, testFun2..方法 , test的t是小写, 这样不会被默认调用</li>\n<li>自定义Test*方法, Test的T 大写, 这样可以被go test 工具识别</li>\n<li>在Test*方法中按顺序 编写 t.Run(&quot;fun_name&quot;, fun)</li>\n<li>编写TestMain方法 , 调用beforeInit, m.Run()(会调用其它Test*方法) afterClear<blockquote>\n<p>不写TestMain方法, 直接在 Test*方法中调用也一样,<br>有TestMain方法时, go test 只会识别 TestMain, 所以要显示调用 m.Run() 来调用其它测试方法 </p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os/exec&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cmd.go  (写在一个文件中方法读代码)</span></span><br><span class=\"line\"><span class=\"comment\">// 待测试方法,</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ExecShell</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tcmd := exec.Command(<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>, s)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> out bytes.Buffer</span><br><span class=\"line\">\tcmd.Stdout = &amp;out</span><br><span class=\"line\">\terr := cmd.Run()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out.String(), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testExecShell</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tt.Log(<span class=\"string\">&quot;testExecShell&quot;</span>)</span><br><span class=\"line\">\t_, err := ExecShell(<span class=\"string\">&quot;ls&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt.Error(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testFun1</span><span class=\"params\">(t *testing.T)</span></span>  &#123;</span><br><span class=\"line\">\tt.Log(<span class=\"string\">&quot;testFun1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">beforeInit</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;beforeInit&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">afterClear</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;afterClear&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestAll</span><span class=\"params\">(t *testing.T)</span></span>  &#123;</span><br><span class=\"line\">\tt.Run(<span class=\"string\">&quot;testExec..&quot;</span>, testExecShell)</span><br><span class=\"line\">\tt.Run(<span class=\"string\">&quot;testfun1&quot;</span>, testFun1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在测试中增加前置/后置函数调用的方法, 思路: 自定义测试的新入口,</span></span><br><span class=\"line\"><span class=\"comment\">// 1 自定义testFun1, testFun2..方法 , test的t是小写, 这样不会被默认调用</span></span><br><span class=\"line\"><span class=\"comment\">// 2 自定义Test*方法, Test的T 大写, 这样可以被go test 工具识别</span></span><br><span class=\"line\"><span class=\"comment\">// 3 在Test*方法中按顺序 编写 t.Run(&quot;fun_name&quot;, fun)</span></span><br><span class=\"line\"><span class=\"comment\">// 4 编写TestMain 方法 , 调用beforeInit, m.Run()(会调用其它Test*方法) afterClear</span></span><br><span class=\"line\"><span class=\"comment\">// 当前不写TestMain方法, 直接在 Test*方法中调用也一样</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;TestMain&quot;</span>)</span><br><span class=\"line\">\tbeforeInit()</span><br><span class=\"line\">\tm.Run()</span><br><span class=\"line\">\tafterClear()</span><br><span class=\"line\">\t<span class=\"comment\">//m.Run()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; go test -v </span><br><span class=\"line\">---------------------</span><br><span class=\"line\">    TestMain</span><br><span class=\"line\">beforeInit</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D; RUN   TestAll</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D; RUN   TestAll&#x2F;testExec..</span><br><span class=\"line\">    cmd_test.go:25: testExecShell</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D; RUN   TestAll&#x2F;testfun1</span><br><span class=\"line\">    cmd_test.go:33: testFun1</span><br><span class=\"line\">--- PASS: TestAll (0.01s)</span><br><span class=\"line\">    --- PASS: TestAll&#x2F;testExec.. (0.01s)</span><br><span class=\"line\">    --- PASS: TestAll&#x2F;testfun1 (0.00s)</span><br><span class=\"line\">PASS</span><br><span class=\"line\">afterClear</span><br><span class=\"line\">ok      com.huoli.saas-manager&#x2F;src&#x2F;common&#x2F;util&#x2F;test     0.022s</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["go test TestMain"]},{"title":"singleflight在并发场景下保护下游业务","url":"/2021/01/07/go4-singleflight/","content":"<h3 id=\"singleflight-使用场景\"><a href=\"#singleflight-使用场景\" class=\"headerlink\" title=\"singleflight 使用场景\"></a>singleflight 使用场景</h3><blockquote>\n<p>针对同一业务的同一批请求(需自定义缓存的 key),只放一个请求去执行，其他等待结果(和普通缓存还不一样), 可以在不使用缓存的情况下,保护下游业务；</p>\n</blockquote>\n<blockquote>\n<p>这是一条测试修改</p>\n</blockquote>\n<blockquote>\n<p>例如 1：在有缓存的数据读取场景中,缓存过期失效时且大并发场景中,瞬间会有大量请求压到数据库,当设置上缓存后才会恢复.但如果去数据库当中查询数据\\内存中计算组装\\设置缓存等操作耗时稍长,同样会存在很大的风险，瞬间的巨量数据库访问,可能会使数据库异常。</p>\n</blockquote>\n<blockquote>\n<p>例如 1：同上,在无缓存的场景中, 如果一个业务完成处理需要 1s, 100 并发情况下, 这 1s 内都会被到服务器执行, 用 singleflight 只会有一个请求被真正处理, 其它的会等 1s(第一个请求处理完成),直接取第一个请求的处理结果 .<br><a href=\"https://studygolang.com/articles/11063\">golang singleflight 用武之地,杨锡坤 2017-09-17</a>如果每个请求都落到下游服务，通常会导致下游服务瞬时负载升高。如果使用缓存，如何判断当前接口请求的内容需要缓存下来？缓存的过期、更新问题？</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现原理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">Do</span><span class=\"params\">(key <span class=\"keyword\">string</span>, fn <span class=\"keyword\">func</span>()</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span>) <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">    g.mu.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        g.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*call)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class=\"line\">        g.mu.Unlock()</span><br><span class=\"line\">        c.wg.Wait() <span class=\"comment\">//其他的请求阻塞</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> c.val, c.err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c := <span class=\"built_in\">new</span>(call)</span><br><span class=\"line\">    c.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    g.m[key] = c</span><br><span class=\"line\">    g.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    c.val, c.err = fn() <span class=\"comment\">//第一个去执行调用</span></span><br><span class=\"line\">    c.wg.Done() <span class=\"comment\">//同一批都返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    g.mu.Lock()</span><br><span class=\"line\">    <span class=\"built_in\">delete</span>(g.m, key)</span><br><span class=\"line\">    g.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c.val, c.err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sample</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestDoDupSuppress</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> g singleflight.Group</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> calls <span class=\"keyword\">int32</span></span><br><span class=\"line\">\tfn := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;inprocess %d\\n&quot;</span>, calls)</span><br><span class=\"line\">\t\tatomic.AddInt32(&amp;calls, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 模拟耗时</span></span><br><span class=\"line\">        time.Sleep(time.Second * <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\">//  回写返回结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> n = <span class=\"number\">30</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(j <span class=\"keyword\">int</span>)</span></span> &#123; <span class=\"comment\">// n个协程同时调用了g.Do，fn中的逻辑只会被一个协程执行</span></span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;before request %d\\n&quot;</span>, j)</span><br><span class=\"line\">\t\t\tv, err := g.Do(<span class=\"string\">&quot;key&quot;</span>, fn)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;after  request %d, %#v\\n&quot;</span>, j, v)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tfmt.Printf(<span class=\"string\">&quot;Do error: %v\\n&quot;</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\twg.Done()</span><br><span class=\"line\">\t\t&#125;(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twg.Wait()</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;done calls= %d\\n&quot;</span>, calls)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["singleflight goroutine"]},{"title":"jsonify 支持对象类型","url":"/2019/08/27/jsonify/","content":"<h3 id=\"使flask-jsonify-支持对象类型的dump\"><a href=\"#使flask-jsonify-支持对象类型的dump\" class=\"headerlink\" title=\"使flask.jsonify 支持对象类型的dump\"></a>使flask.jsonify 支持对象类型的dump</h3><pre><code>flask.jsonify 默认支持字典类型的参数, 返回json化的字符串, mimetype 为 application/json, 要注意的是它不支持list入我们自定义的对象 , 下面尝试扩展其功能\n\nflask.wrapers.Response.data\n\nwith app.test_request_context(&#39;/&#39;, method=&#39;POST&#39;) as new_context:\n    print jsonify(a=[1,2,3]).data</code></pre>\n","tags":["web, flask ,jsonify"]},{"title":"go test -v","url":"/2019/08/07/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<hr>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"常见的Web攻击手段之CSRF攻击","url":"/2019/08/31/httponly/","content":"<h1 id=\"安全-常见的Web攻击手段之CSRF攻击-转载\"><a href=\"#安全-常见的Web攻击手段之CSRF攻击-转载\" class=\"headerlink\" title=\"安全|常见的Web攻击手段之CSRF攻击(转载)\"></a>安全|常见的Web攻击手段之CSRF攻击(转载)</h1><!-- 作者区域 -->\n\n\n<p><a href=\"https://www.jianshu.com/p/67408d73c66d\">转载自简书</a></p>\n<!-- 文章内容 -->\n\n<p>对于常规的Web攻击手段，如XSS、CRSF、SQL注入、（常规的不包括文件上传漏洞、DDoS攻击）等，防范措施相对来说比较容易，对症下药即可，比如XSS的防范需要转义掉输入的尖括号，防止CRSF攻击需要将cookie设置为httponly，以及增加session相关的Hash token码 ，SQL注入的防范需要将分号等字符转义，等等做起来虽然筒单，但却容易被忽视，更多的是需要<strong>从开发流程上来予以保障</strong>（这句话是给技术管理者的建议），以免因人为的疏忽而造成损失。</p>\n<h3 id=\"一、CSRF介绍\"><a href=\"#一、CSRF介绍\" class=\"headerlink\" title=\"一、CSRF介绍\"></a>一、CSRF介绍</h3><p>CSRF攻击的全称是跨站请求伪造（ cross site request forgery)，是一种对网站的恶意利用，尽管听起来跟XSS跨站脚本攻击有点相似，但事实上CSRF与XSS差别很大，XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。你可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义向第三方网站发送恶意请求。 CRSF能做的事情包括利用你的身份发邮件、发短信、进行交易转账等，甚至盗取你的账号。</p>\n<h4 id=\"1-1、CRSF攻击原理\"><a href=\"#1-1、CRSF攻击原理\" class=\"headerlink\" title=\"1.1、CRSF攻击原理\"></a>1.1、CRSF攻击原理</h4><p><img src=\"htts://upload-images.jianshu.io/upload_images/5219651-7af31f65db312f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp\" loading=\"lazy\"></p>\n<p>CRSF攻击原理</p>\n<ol>\n<li> 首先用户C浏览并登录了受信任站点A；</li>\n<li> 登录信息验证通过以后，站点A会在返回给浏览器的信息中带上已登录的cookie，cookie信息会在浏览器端保存一定时间（根据服务端设置而定）；</li>\n<li> 完成这一步以后，用户在没有登出（清除站点A的cookie）站点A的情况下，访问恶意站点B；</li>\n<li> 这时恶意站点 B的某个页面向站点A发起请求，而这个请求会带上浏览器端所保存的站点A的cookie；</li>\n<li> 站点A根据请求所带的cookie，判断此请求为用户C所发送的。</li>\n</ol>\n<p>因此，站点A会报据用户C的权限来处理恶意站点B所发起的请求，而这个请求可能以用户C的身份发送 邮件、短信、消息，以及进行转账支付等操作，这样恶意站点B就达到了伪造用户C请求站点 A的目的。<br>受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击：</p>\n<ul>\n<li>登录受信任站点 A，并在本地生成cookie；</li>\n<li>在不登出站点A（清除站点A的cookie）的情况下，访问恶意站点B。</li>\n</ul>\n<p>很多情况下所谓的恶意站点，很有可能是一个存在其他漏洞（如XSS）的受信任且被很多人访问的站点，这样，普通用户可能在不知不觉中便成为了受害者。</p>\n<h4 id=\"1-2、攻击举例\"><a href=\"#1-2、攻击举例\" class=\"headerlink\" title=\"1.2、攻击举例\"></a>1.2、攻击举例</h4><p>假设某银行网站A以GET请求来发起转账操作，转账的地址为<code>www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000</code>，参数accountNum表示转账的账户，参数money表示转账金额。<br>而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：<code>&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt;</code><br>当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块...<br>为什么会这样呢，在你登录银行A时，你的浏览器端会生成银行A的cookie，而当你访问论坛B的时候，页面上的<img>标签需要浏览器发起一个新的HTTP请求，以获得图片资源，当浏览器发起请求时，请求的却是银行A的转账地址<code>www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000</code>，并且会带上银行A的cookie信息，结果银行的服务器收到这个请求后，会以为是你发起的一次转账操作，因此你的账号里边便少了10000块。<br>当然，绝大多数网站都不会使用GET请求来进行数据更新，因此，攻击者也需要改变思路，与时俱进。<br>假设银行将其转账方式改成POST提交，而论坛B恰好又存在一个XSS漏洞，恶意用户在它的页面上植入如下代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;aaa&quot;</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;http://www.xxx.com/transfer.do&quot;</span> <span class=\"attr\">metdod</span>=<span class=\"string\">&quot;POST&quot;</span> <span class=\"attr\">display</span>=<span class=\"string\">&quot;none&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;accountNum&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10001&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;money&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> form = <span class=\"built_in\">document</span>.forms(<span class=\"string\">&#x27;aaa&#x27;</span>);</span></span><br><span class=\"line\">    form.submit();</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果你此时恰好登录了银行A，且没有登出，当你打开上述页面后，脚本会将表单aaa提交，把accountNum和money参数传递给银行的转账地址<code>http://www.xxx.com/transfer.do</code>，同样的，银行以为是你发起的一次转账会从你的账户中扣除10000块。<br>当然，以上只是举例，正常来说银行的交易付款会有USB key、验证码、登录密码和支付密码等一系列屏障，流程比上述流程复杂得多，因此安全系数也高得多。</p>\n<h4 id=\"1-3、CSRF的防御\"><a href=\"#1-3、CSRF的防御\" class=\"headerlink\" title=\"1.3、CSRF的防御\"></a>1.3、CSRF的防御</h4><p><strong>1、尽量使用POST，限制GET</strong><br>GET接口太容易被拿来做CSRF攻击，看上面示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。<br>当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。<br><strong>2、将cookie设置为HttpOnly</strong><br>CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的XSS漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。<br>在Java的Servlet的API中设置cookie为HttpOnly的代码如下：<br><code>response.setHeader( &quot;Set-Cookie&quot;, &quot;cookiename=cookievalue;HttpOnly&quot;);</code><br><strong>3、增加token</strong><br>CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：<strong>在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中</strong>。鉴于此，系统开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求。<br>假设请求通过POST方式提交，则可以在相应的表单中增加一个隐藏域：<br><code>&lt;input type=&quot;hidden&quot; name=&quot;_toicen&quot; value=&quot;tokenvalue&quot;/&gt;</code><br>token的值通过服务端生成，表单提交后token的值通过POST请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者因无法获取到token，也就无法伪造请求。<br>在session中添加token的实现代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpSession session = request.getSession();</span><br><span class=\"line\"><span class=\"built_in\">Object</span> token = session.getAttribute(<span class=\"string\">&quot;_token&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(token == <span class=\"literal\">null</span> I I <span class=\"string\">&quot;&quot;</span>.equals(token)) &#123;</span><br><span class=\"line\">    session.setAttribute(<span class=\"string\">&quot;_token&quot;</span>, UUID.randomUUIDO .toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>4、通过Referer识别</strong><br>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问<code>http://www.xxx.com/transfer.do</code>页面完成的，用户必须先登录<code>www.xxx.com</code>，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是<br>提交按钮所在页面的URL（本例为<a href=\"https://link.jianshu.com/?t=http://www.xxx\">www.xxx</a>. com/<a href=\"https://link.jianshu.com/?t=http://transfer.do\">transfer.do</a>）。如果攻击者要对银行网站实施CSRF攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的Referer的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值即可，如果是以<code>www.xx.om</code>域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。<br>取得HTTP请求Referer：<br><code>String referer = request.getHeader(&quot;Referer&quot;);</code></p>\n<h3 id=\"二、总结\"><a href=\"#二、总结\" class=\"headerlink\" title=\"二、总结\"></a>二、总结</h3><p>CSRF攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式，通常使用Anti CSRF Token来防御CSRF攻击，同时要注意Token的保密性和随机性。<br>并且CSRF攻击问题一般是由服务端解决。<br>注：文章大部分内容来源于《大型分布式网站架构 设计与实践》一书。</p>\n","tags":["web, csrf ,xss"]},{"title":"json 格式化 datetime, date","url":"/2019/08/13/json-format/","content":"<p>json.dumps() 对datetime.datetime, datetime.date类型数据无法识别会报错, 需要自定义encoder 来解决<br>在学习flask的源码中,了解了偏函数 ,可以创建原函数的代理,支持预设参数,还可保留原来该用方式</p>\n<p>代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DateEncoder</span>(<span class=\"params\">json.JSONEncoder</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span>(<span class=\"params\">self, obj</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(obj, datetime.datetime):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> obj.strftime(<span class=\"string\">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(obj, datetime.date):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> obj.strftime(<span class=\"string\">&quot;%Y-%m-%d&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> json.JSONEncoder.default(self, obj)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">json_dump=partial(json.dumps, ensure_ascii=<span class=\"literal\">False</span>, cls=DateEncoder)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>调用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, <span class=\"built_in\">id</span>, sname</span>):</span></span><br><span class=\"line\">        self.<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span></span><br><span class=\"line\">        self.sname=sname</span><br><span class=\"line\">        self.time=datetime.datetime.now()</span><br><span class=\"line\">        self.sname_zh=<span class=\"string\">&#x27;汉字&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self_dict = copy.deepcopy(self.__dict__)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> json_dump(self_dict, indent=<span class=\"number\">2</span> )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> User(<span class=\"number\">1</span>, <span class=\"string\">&#x27;admin&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;time&quot;</span>: <span class=\"string\">&quot;2019-08-13 14:04:21&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;sname&quot;</span>: <span class=\"string\">&quot;admin&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;sname_zh&quot;</span>: <span class=\"string\">&quot;汉字&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","tags":["json ,  partial"]},{"title":"pandas 简单使用","url":"/2019/08/14/pandas_123/","content":"<p>pandas的简单使用记录</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><ul>\n<li><p>由数据库查询创建</p>\n</li>\n<li><p>自定义数据创建</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">lst=[[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;apple&#x27;</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"string\">&#x27;banan&#x27;</span>]]</span><br><span class=\"line\">frm=pd.DataFrame(lst, columns=[<span class=\"string\">&#x27;tag1&#x27;</span>,<span class=\"string\">&#x27;tag2&#x27;</span>, <span class=\"string\">&#x27;tag3&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建子集 , 可指定行区间\\列名</span></span><br><span class=\"line\">frm2=frm.loc[:,[<span class=\"string\">&#x27;tag1&#x27;</span>, <span class=\"string\">&#x27;tag3&#x27;</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从表中读取</span></span><br><span class=\"line\">query = Model.query.session.query(Model.local_date, Model.data_source, func.<span class=\"built_in\">sum</span>(Model.total).label(<span class=\"string\">&#x27;t&#x27;</span>), func.<span class=\"built_in\">sum</span>(Model.count).label(<span class=\"string\">&#x27;c&#x27;</span>))</span><br><span class=\"line\"><span class=\"keyword\">with</span> AlchemyDbUtil(db, <span class=\"string\">&#x27;statistics&#x27;</span>) <span class=\"keyword\">as</span> dbutil:</span><br><span class=\"line\">    pdf=pd.read_sql(query.statement, dbutil.conn)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><pre><code>* head, tail, describle()\n\n\n* 排序\n    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">frame.sort_index(by=[<span class=\"string\">&#x27;column1&#x27;</span>],ascending=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n\n* 过滤\n    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清除null</span></span><br><span class=\"line\">frm3=frm2.dropna(subset=[<span class=\"string\">&#x27;tag2&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 一行数据只要有一个字段存在空值即删除</span></span><br><span class=\"line\">frm2.dropna(axis=<span class=\"number\">0</span>, how=<span class=\"string\">&quot;any&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#how 参数可选的值为 any（默认） 或者 all。any 表示一行/列有任意元素为空时即丢弃，all 一行/列所有值都为空时才丢弃。</span></span><br><span class=\"line\"><span class=\"comment\">#subset 参数表示删除时只考虑的索引或列名。</span></span><br><span class=\"line\"><span class=\"comment\">#thresh参数的类型为整数，它的作用是，比如 thresh=3，会在一行/列中至少有 3 个非空值时将其保留。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 过滤空串</span></span><br><span class=\"line\">frm3=frm3[frm3[<span class=\"string\">&#x27;tag2&#x27;</span>]!=<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按条件过滤</span></span><br><span class=\"line\">frm3=frm3[frm3[<span class=\"string\">&#x27;tag2&#x27;</span>]!=frm3[<span class=\"string\">&#x27;tag1&#x27;</span>]]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取toplist</span></span><br><span class=\"line\">frm_main.nlargest(<span class=\"number\">10</span>, <span class=\"string\">&#x27;cnt&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分组后取toplist  nlargest()的第一个参数就是截取的行数。第二个参数就是依据的列名</span></span><br><span class=\"line\">frm_main.groupby(by=[<span class=\"string\">&#x27;airline_code&#x27;</span>, <span class=\"string\">&#x27;iata_code&#x27;</span>]).apply(<span class=\"keyword\">lambda</span> x: x.nlargest(<span class=\"number\">1</span>,<span class=\"string\">&quot;cnt&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n* 遍历\n\n    |tag1|    tag2|    cnt|\n    |---|---|---|\n    |6H |C3|6|\n    |8Q    |SV|4|\n    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> idx , item  <span class=\"keyword\">in</span> frm4.iterrows():</span><br><span class=\"line\">     <span class=\"built_in\">print</span> idx, <span class=\"string\">&#x27;--&#x27;</span>, item[<span class=\"number\">0</span>], item[<span class=\"number\">1</span>], item[<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n* 导出 to_csv, clipboard ...\n\n  ![示例](http://ww3.sinaimg.cn/large/006tNc79ly1g60imisu3qj305205vglt.jpg)\n\n* 统计\n    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 相当于groupby tag1, tag2 having count(1) &gt;2</span></span><br><span class=\"line\">frm4=frm3.groupby([<span class=\"string\">&#x27;tag1&#x27;</span>, <span class=\"string\">&#x27;tag2&#x27;</span>]).size().reset_index(name=<span class=\"string\">&#x27;cnt&#x27;</span>).query(<span class=\"string\">&#x27;cnt &gt;2&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></code></pre>\n<h3 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h3><pre><code>* 动态生成\\修改列\n    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 由其它列生成</span></span><br><span class=\"line\">frm[<span class=\"string\">&#x27;tag_short&#x27;</span>]=frm[<span class=\"string\">&#x27;tag3&#x27;</span>].<span class=\"built_in\">str</span>[:<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 由其它函数生成</span></span><br><span class=\"line\">reg_dict=&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> idx <span class=\"keyword\">in</span> frm.index:</span><br><span class=\"line\">    frm.loc[idx][<span class=\"string\">&#x27;tag_new&#x27;</span>]=reg_dict.get(frm.loc[idx][<span class=\"string\">&#x27;key&#x27;</span>], <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 由lambda表达式生成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">apply_func</span>(<span class=\"params\">df</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reg_dict.get(df[<span class=\"string\">&#x27;key&#x27;</span>], <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">frm[<span class=\"string\">&#x27;tag_new&#x27;</span>]=frm.apply(<span class=\"keyword\">lambda</span> r:apply_apairline(r), axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n* 清除空数据\n    <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># # 可以通过subset参数来删除在age和sex中含有空数据的全部行</span></span><br><span class=\"line\">df4 = df4.dropna(subset=[<span class=\"string\">&quot;age&quot;</span>, <span class=\"string\">&quot;sex&quot;</span>])</span><br></pre></td></tr></table></figure></code></pre>\n"},{"title":"转载sqlalchemy 简单使用","url":"/2019/08/20/sqlalchemy_123/","content":"<p><a href=\"https://www.jianshu.com/p/8d085e2f2657\">转载自jianshu https://www.jianshu.com/p/8d085e2f2657</a></p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/0d234e14b5d3\">SQLAlchemy ORM教程之一：Create</a></li>\n<li><a href=\"https://www.jianshu.com/p/8d085e2f2657\">SQLAlchemy ORM教程之二：Query （本文）</a></li>\n<li><a href=\"https://www.jianshu.com/p/9771b0a3e589\">SQLAlchemy ORM教程之三：Relationship</a></li>\n</ul>\n<hr>\n<p>这是继<a href=\"https://www.jianshu.com/p/0d234e14b5d3\">SQLAlchemy ORM教程之一：Create</a>后的第二篇教程。在上一篇中我们主要是解决了如何配置ORM系统，建立从类到表的映射的过程，以及如何插入和修改记录。在这个教程中我们主要解决使用的问题。</p>\n<h3 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h3><p><code>Session</code>的<code>query</code>函数会返回一个<code>Query</code>对象。<code>query</code>函数可以接受多种参数类型。可以是类，或者是类的instrumented <strong>descriptor</strong>。下面的这个例子取出了所有的<code>User</code>记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> instance <span class=\"keyword\">in</span> session.query(User).order_by(User.id):</span><br><span class=\"line\">...     <span class=\"built_in\">print</span>(instance.name, instance.fullname)</span><br><span class=\"line\">ed Ed Jones</span><br><span class=\"line\">wendy Wendy Williams</span><br><span class=\"line\">mary Mary Contrary</span><br><span class=\"line\">fred Fred Flinstone</span><br></pre></td></tr></table></figure>\n<p><code>Query</code>也接受ORM-instrumented descriptors作为参数。当多个参数传入时，返回结果为以同样顺序排列的tuples</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> name, fullname <span class=\"keyword\">in</span> session.query(User.name, User.fullname):</span><br><span class=\"line\">...     <span class=\"built_in\">print</span>(name, fullname)</span><br><span class=\"line\">ed Ed Jones</span><br><span class=\"line\">wendy Wendy Williams</span><br><span class=\"line\">mary Mary Contrary</span><br><span class=\"line\">fred Fred Flinstone</span><br></pre></td></tr></table></figure>\n<p><code>Query</code>返回的tuples由<code>KeyedTuple</code>这个类提供，其成员除了用下标访问意外，还可以视为实例变量来获取。对应的变量的名称与被查询的类变量名称一样，如下例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> session.query(User, User.name).all():</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(row.User, row.name)</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;ed&#x27;</span>, fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>, password=<span class=\"string\">&#x27;f8s7ccs&#x27;</span>)&gt; ed</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;wendy&#x27;</span>, fullname=<span class=\"string\">&#x27;Wendy Williams&#x27;</span>, password=<span class=\"string\">&#x27;foobar&#x27;</span>)&gt; wendy</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;mary&#x27;</span>, fullname=<span class=\"string\">&#x27;Mary Contrary&#x27;</span>, password=<span class=\"string\">&#x27;xxg527&#x27;</span>)&gt; mary</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;fred&#x27;</span>, fullname=<span class=\"string\">&#x27;Fred Flinstone&#x27;</span>, password=<span class=\"string\">&#x27;blah&#x27;</span>)&gt; fred</span><br></pre></td></tr></table></figure>\n<p>你可以通过<code>label()</code>来制定descriptor对应实例变量的名称</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> session.query(User.name.label(<span class=\"string\">&#x27;name_label&#x27;</span>)).all():</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(row.name_label)</span><br><span class=\"line\">ed</span><br><span class=\"line\">wendy</span><br><span class=\"line\">mary</span><br><span class=\"line\">fred</span><br></pre></td></tr></table></figure>\n<p>而对于类参数而言，要实现同样的定制需要使用<code>aliased</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from sqlalchemy.orm import aliased</span><br><span class=\"line\">&gt;&gt;&gt; user_alias = aliased(User, name=<span class=\"string\">&#x27;user_alias&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">SQL&gt;&gt;&gt; <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> session.query(user_alias, user_alias.name).all():</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(row.user_alias)</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;ed&#x27;</span>, fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>, password=<span class=\"string\">&#x27;f8s7ccs&#x27;</span>)&gt;</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;wendy&#x27;</span>, fullname=<span class=\"string\">&#x27;Wendy Williams&#x27;</span>, password=<span class=\"string\">&#x27;foobar&#x27;</span>)&gt;</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;mary&#x27;</span>, fullname=<span class=\"string\">&#x27;Mary Contrary&#x27;</span>, password=<span class=\"string\">&#x27;xxg527&#x27;</span>)&gt;</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;fred&#x27;</span>, fullname=<span class=\"string\">&#x27;Fred Flinstone&#x27;</span>, password=<span class=\"string\">&#x27;blah&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>\n<p>基本的查询操作除了上面这些之外，还包括OFFSET和LIMIT，这个可以通过Python的array slice来完成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> u <span class=\"keyword\">in</span> session.query(User).order_by(User.id)[1:3]:</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(u)</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;wendy&#x27;</span>, fullname=<span class=\"string\">&#x27;Wendy Williams&#x27;</span>, password=<span class=\"string\">&#x27;foobar&#x27;</span>)&gt;</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;mary&#x27;</span>, fullname=<span class=\"string\">&#x27;Mary Contrary&#x27;</span>, password=<span class=\"string\">&#x27;xxg527&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>\n<p>上述过程实际上只涉及了整体取出的操作，而没有进行筛选，筛选常用的函数是<code>filter_by</code>和<code>filter</code>。其中后者比起前者要更灵活一些，你可以在后者的参数中使用python的运算符。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> name, <span class=\"keyword\">in</span> session.query(User.name).\\</span><br><span class=\"line\">...             filter_by(fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>):</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">ed</span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> name, <span class=\"keyword\">in</span> session.query(User.name).\\</span><br><span class=\"line\">...             filter(User.fullname==<span class=\"string\">&#x27;Ed Jones&#x27;</span>):</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">ed</span><br></pre></td></tr></table></figure>\n<p>注意<code>Query</code>对象是<strong>generative</strong>的，这意味你可以把他们串接起来调用，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> session.query(User).\\</span><br><span class=\"line\">...          filter(User.name==<span class=\"string\">&#x27;ed&#x27;</span>).\\</span><br><span class=\"line\">...          filter(User.fullname==<span class=\"string\">&#x27;Ed Jones&#x27;</span>):</span><br><span class=\"line\">...    <span class=\"built_in\">print</span>(user)</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;ed&#x27;</span>, fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>, password=<span class=\"string\">&#x27;f8s7ccs&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>\n<p>串接的<code>filter</code>之间是<strong>与</strong>的关系。</p>\n<h3 id=\"常用的filter操作符\"><a href=\"#常用的filter操作符\" class=\"headerlink\" title=\"常用的filter操作符\"></a>常用的filter操作符</h3><p>下面的这些操作符可以应用在<code>filter</code>函数中</p>\n<ul>\n<li><code>equals</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name == <span class=\"string\">&#x27;ed&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>not equals</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name != <span class=\"string\">&#x27;ed&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>LIKE</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name.like(<span class=\"string\">&#x27;%ed%&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>IN</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name.in_([<span class=\"string\">&#x27;ed&#x27;</span>, <span class=\"string\">&#x27;wendy&#x27;</span>, <span class=\"string\">&#x27;jack&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># works with query objects too:</span></span><br><span class=\"line\">query.filter(User.name.in_(</span><br><span class=\"line\">        session.query(User.name).filter(User.name.like(<span class=\"string\">&#x27;%ed%&#x27;</span>))</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>NOT IN</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(~User.name.in_([<span class=\"string\">&#x27;ed&#x27;</span>, <span class=\"string\">&#x27;wendy&#x27;</span>, <span class=\"string\">&#x27;jack&#x27;</span>]))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>IS NULL</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name == None)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># alternatively, if pep8/linters are a concern</span></span><br><span class=\"line\">query.filter(User.name.is_(None))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>IS NOT NULL</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name != None)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># alternatively, if pep8/linters are a concern</span></span><br><span class=\"line\">query.filter(User.name.isnot(None))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>AND</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># use and_()</span></span><br><span class=\"line\">from sqlalchemy import and_</span><br><span class=\"line\">query.filter(and_(User.name == <span class=\"string\">&#x27;ed&#x27;</span>, User.fullname == <span class=\"string\">&#x27;Ed Jones&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># or send multiple expressions to .filter()</span></span><br><span class=\"line\">query.filter(User.name == <span class=\"string\">&#x27;ed&#x27;</span>, User.fullname == <span class=\"string\">&#x27;Ed Jones&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># or chain multiple filter()/filter_by() calls</span></span><br><span class=\"line\">query.filter(User.name == <span class=\"string\">&#x27;ed&#x27;</span>).filter(User.fullname == <span class=\"string\">&#x27;Ed Jones&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>OR</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">from sqlalchemy import or_</span><br><span class=\"line\">query.filter(or_(User.name == <span class=\"string\">&#x27;ed&#x27;</span>, User.name == <span class=\"string\">&#x27;wendy&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>MATCH</code>:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">query.filter(User.name.match(<span class=\"string\">&#x27;wendy&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<h3 id=\"返回列表-List-和单项-Scalar\"><a href=\"#返回列表-List-和单项-Scalar\" class=\"headerlink\" title=\"返回列表(List)和单项(Scalar)\"></a>返回列表(List)和单项(Scalar)</h3><p>很多<code>Query</code>的方法执行了SQL命令并返回了取出的数据库结果。</p>\n<ul>\n<li><code>all()</code>返回一个列表:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; query = session.query(User).filter(User.name.like(<span class=\"string\">&#x27;%ed&#x27;</span>)).order_by(User.id)</span><br><span class=\"line\">SQL&gt;&gt;&gt; query.all()</span><br><span class=\"line\">[&lt;User(name=<span class=\"string\">&#x27;ed&#x27;</span>, fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>, password=<span class=\"string\">&#x27;f8s7ccs&#x27;</span>)&gt;,</span><br><span class=\"line\">      &lt;User(name=<span class=\"string\">&#x27;fred&#x27;</span>, fullname=<span class=\"string\">&#x27;Fred Flinstone&#x27;</span>, password=<span class=\"string\">&#x27;blah&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>first()</code>返回至多一个结果，而且以单项形式，而不是只有一个元素的tuple形式返回这个结果.</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; query.first()</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;ed&#x27;</span>, fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>, password=<span class=\"string\">&#x27;f8s7ccs&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>one()</code>返回且仅返回一个查询结果。当结果的数量不足一个或者多于一个时会报错。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; user = query.one()</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">...</span><br><span class=\"line\">MultipleResultsFound: Multiple rows were found <span class=\"keyword\">for</span> one()</span><br></pre></td></tr></table></figure>\n<p>没有查找到结果时：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; user = query.filter(User.id == <span class=\"number\">99</span>).one()</span><br><span class=\"line\">Traceback (most recent call last)<span class=\"symbol\">:</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"symbol\">NoResultFound:</span> No row was found <span class=\"keyword\">for</span> one()</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>one_or_none()</code>：从名称可以看出，当结果数量为0时返回<code>None</code>， 多于1个时报错</p>\n</li>\n<li><p><code>scalar()</code>和<code>one()</code>类似，但是返回单项而不是tuple</p>\n</li>\n</ul>\n<h3 id=\"嵌入使用SQL\"><a href=\"#嵌入使用SQL\" class=\"headerlink\" title=\"嵌入使用SQL\"></a>嵌入使用SQL</h3><p>你可以在<code>Query</code>中通过<code>text()</code>使用SQL语句。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from sqlalchemy import text</span><br><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> session.query(User).\\</span><br><span class=\"line\">...             filter(text(<span class=\"string\">&quot;id&lt;224&quot;</span>)).\\</span><br><span class=\"line\">...             order_by(text(<span class=\"string\">&quot;id&quot;</span>)).all():</span><br><span class=\"line\">...     <span class=\"built_in\">print</span>(user.name)</span><br><span class=\"line\">ed</span><br><span class=\"line\">wendy</span><br><span class=\"line\">mary</span><br><span class=\"line\">fred</span><br></pre></td></tr></table></figure>\n<p>除了上面这种直接将参数写进字符串的方式外，你还可以通过<code>params()</code>方法来传递参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; session.query(User).filter(text(<span class=\"string\">&quot;id&lt;:value and name=:name&quot;</span>)).\\</span><br><span class=\"line\">...     params(value=224, name=<span class=\"string\">&#x27;fred&#x27;</span>).order_by(User.id).one()</span><br><span class=\"line\">&lt;User(name=<span class=\"string\">&#x27;fred&#x27;</span>, fullname=<span class=\"string\">&#x27;Fred Flinstone&#x27;</span>, password=<span class=\"string\">&#x27;blah&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>\n<p>并且，你可以直接使用完整的SQL语句，但是要注意将表名和列明写正确。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; session.query(User).from_statement(</span><br><span class=\"line\">...                     text(<span class=\"string\">&quot;SELECT * FROM users where name=:name&quot;</span>)).\\</span><br><span class=\"line\">...                     params(name=<span class=\"string\">&#x27;ed&#x27;</span>).all()</span><br><span class=\"line\">[&lt;User(name=<span class=\"string\">&#x27;ed&#x27;</span>, fullname=<span class=\"string\">&#x27;Ed Jones&#x27;</span>, password=<span class=\"string\">&#x27;f8s7ccs&#x27;</span>)&gt;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"计数\"><a href=\"#计数\" class=\"headerlink\" title=\"计数\"></a>计数</h3><p><code>Query</code>定义了一个很方便的计数函数<code>count()</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; session.query(User).filter(User.name.like(<span class=\"string\">&#x27;%ed&#x27;</span>)).count()</span><br><span class=\"line\">SELECT count(*) AS count_1</span><br><span class=\"line\">FROM (SELECT users.id AS users_id,</span><br><span class=\"line\">                users.name AS users_name,</span><br><span class=\"line\">                users.fullname AS users_fullname,</span><br><span class=\"line\">                users.password AS users_password</span><br><span class=\"line\">FROM users</span><br><span class=\"line\">WHERE users.name LIKE ?) AS anon_1</span><br><span class=\"line\">(<span class=\"string\">&#x27;%ed&#x27;</span>,)</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<p>注意上面我们同时列出了实际的SQL指令。在SQLAlchemy中，我们总是将被计数的查询打包成一个子查询，然后对这个子查询进行计数。即便是最简单的<code>SELECT count(*) FROM table</code>，也会如此处理。为了更精细的控制计数过程，我们可以采用<code>func.count()</code>这个函数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from sqlalchemy import func</span><br><span class=\"line\">SQL&gt;&gt;&gt; session.query(func.count(User.name).label(<span class=\"string\">&#x27;ucnt&#x27;</span>), User.name).group_by(User.name).all()</span><br><span class=\"line\">SELECT count(users.name) AS count_1, users.name AS users_name</span><br><span class=\"line\">FROM users GROUP BY users.name</span><br><span class=\"line\">()</span><br><span class=\"line\">[(1, u<span class=\"string\">&#x27;ed&#x27;</span>), (1, u<span class=\"string\">&#x27;fred&#x27;</span>), (1, u<span class=\"string\">&#x27;mary&#x27;</span>), (1, u<span class=\"string\">&#x27;wendy&#x27;</span>)]</span><br></pre></td></tr></table></figure>\n<p>为了实现最简单的<code>SELECT count(*) FROM table</code>，我们可以如下调用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; session.query(func.count(<span class=\"string\">&#x27;*&#x27;</span>).label(<span class=\"string\">&#x27;ucnt&#x27;</span>)).select_from(User).scalar()</span><br><span class=\"line\">SELECT count(?) AS count_1</span><br><span class=\"line\">FROM users</span><br><span class=\"line\">(<span class=\"string\">&#x27;*&#x27;</span>,)</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<p>如果我们对<code>User</code>的主键进行计数，那么<code>select_from</code>也可以省略。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; session.query(func.count(User.id)).scalar()</span><br><span class=\"line\">SELECT count(users.id) AS count_1</span><br><span class=\"line\">FROM users</span><br><span class=\"line\">()</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<h4 id=\"在下一篇教程里面我们将会介绍SQLAlchemy对于『关系』的处理方式，以及针对关系的更加复杂的查询。\"><a href=\"#在下一篇教程里面我们将会介绍SQLAlchemy对于『关系』的处理方式，以及针对关系的更加复杂的查询。\" class=\"headerlink\" title=\"在下一篇教程里面我们将会介绍SQLAlchemy对于『关系』的处理方式，以及针对关系的更加复杂的查询。\"></a>在下一篇教程里面我们将会介绍SQLAlchemy对于『关系』的处理方式，以及针对关系的更加复杂的查询。</h4><p>教程的第三部分传送门<a href=\"https://www.jianshu.com/p/9771b0a3e589\">SQLAlchemy ORM教程之三：Relationship</a></p>\n","tags":["sqlalchemy, orm"]},{"title":"py.test 测试,mock","url":"/2019/10/24/py-test/","content":"<h4 id=\"pytest使用方法\"><a href=\"#pytest使用方法\" class=\"headerlink\" title=\"pytest使用方法\"></a>pytest使用方法</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定测试文件</span></span><br><span class=\"line\">py.test -v test_functions.py</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定测试目录</span></span><br><span class=\"line\">py.test -v .</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\"># 目录结构</span></span><br><span class=\"line\"><span class=\"string\">test</span></span><br><span class=\"line\"><span class=\"string\">  .</span></span><br><span class=\"line\"><span class=\"string\">  ├── __init__.py</span></span><br><span class=\"line\"><span class=\"string\">  ├── functions.py   # 方法文件</span></span><br><span class=\"line\"><span class=\"string\">  ├── test_app.py    # 测试文件</span></span><br><span class=\"line\"><span class=\"string\">  └── test_functions.py   # 测试文件</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># functions.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiple</span>(<span class=\"params\">x,y </span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*y +<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_and_multiply</span>(<span class=\"params\">x,y </span>):</span></span><br><span class=\"line\">    addition=x+y</span><br><span class=\"line\">    multi=multiple(x,y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (addition, multi)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test_functions.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_and_multiply</span>():</span></span><br><span class=\"line\">    x,y=<span class=\"number\">3</span>,<span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    addi, multi=add_and_multiply(x,y )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> addi==<span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> multi==<span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 要mock的方法要写全路径</span></span><br><span class=\"line\"><span class=\"meta\">@mock.patch(<span class=\"params\"><span class=\"string\">&#x27;test.functions.multiple&#x27;</span>, return_value=<span class=\"number\">15</span> </span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_and_multiply_mock</span>(<span class=\"params\">mock_func</span>):</span></span><br><span class=\"line\">    x = <span class=\"number\">3</span></span><br><span class=\"line\">    y = <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"comment\"># 要mock的方法需指定绝对路径</span></span><br><span class=\"line\">    <span class=\"comment\"># test.functions.multiple=mock.Mock(return_value=15)</span></span><br><span class=\"line\">    addi, multi= add_and_multiply(x, y)</span><br><span class=\"line\">    print()</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> addi == <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> multi == <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_and_multiply_mock2</span>():</span></span><br><span class=\"line\">    x = <span class=\"number\">3</span></span><br><span class=\"line\">    y = <span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"comment\"># 要mock的方法需指定绝对路径</span></span><br><span class=\"line\">    test.functions.multiple=mock.Mock(return_value=<span class=\"number\">15</span>)</span><br><span class=\"line\">    addi, multi= add_and_multiply(x, y)</span><br><span class=\"line\">    print()</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> addi == <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> multi == <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>&#39;&#39;&#39;bash</p>\n<h4 id=\"指定测试文件\"><a href=\"#指定测试文件\" class=\"headerlink\" title=\"指定测试文件\"></a>指定测试文件</h4><p>py.test -v test_functions.py</p>\n<h4 id=\"指定测试目录\"><a href=\"#指定测试目录\" class=\"headerlink\" title=\"指定测试目录\"></a>指定测试目录</h4><p>py.test -v .</p>\n<p>py.test -v test_functions.py<br>collected 3 items</p>\n<p>test_functions.py::test_add_and_multiply FAILED               [ 33%]<br>test_functions.py::test_add_and_multiply_mock PASSED          [ 66%]<br>test_functions.py::test_add_and_multiply_mock2 PASSED         [100%]</p>\n<p>=============== FAILURES ============<br>___________test_add_and_multiply _____</p>\n<pre><code>def test_add_and_multiply():\n    x,y=3,5\n\n    addi, multi=add_and_multiply(x,y )\n\n    assert addi==8</code></pre>\n<blockquote>\n<pre><code>  assert multi==15</code></pre>\n<p>E       assert 25 == 15<br>E         -25<br>E         +15</p>\n</blockquote>\n<p>test_functions.py:21: AssertionError<br>=============== 1 failed, 2 passed in 0.14s ===========</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["pytest, mock"]},{"title":"vuejs 列表中的元素,要动态绑定多个样式","url":"/2019/09/20/vue-class/","content":"<p>用以下的方法 没有成功</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">:<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;&#123; done: item.handled==1 , ignore: item.handled==2, ignore2: item.handled==3 &#125;&quot;</span> &gt;</span><br></pre></td></tr></table></figure>\n<p>后来发现下面的方法更稳拓些 , 也方便调整</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">:<span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;[gethandle_class(item.handled), getstatus_class(item.status)] &quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    gethandle_class: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">handle_v</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">              <span class=\"string\">&quot;1&quot;</span>: <span class=\"string\">&quot;done&quot;</span>,</span><br><span class=\"line\">              <span class=\"string\">&quot;2&quot;</span>: <span class=\"string\">&quot;ig&quot;</span>,</span><br><span class=\"line\">              <span class=\"string\">&quot;3&quot;</span>: <span class=\"string\">&quot;ig&quot;</span>,</span><br><span class=\"line\">          &#125;[handle_v]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["vuejs, class"]},{"title":"py37 pandas升级后提示缺少bz2","url":"/2020/11/20/py37-pandas-bz2/","content":"<h4 id=\"py37-pandas升级后提示缺少bz2\"><a href=\"#py37-pandas升级后提示缺少bz2\" class=\"headerlink\" title=\"py37 pandas升级后提示缺少bz2\"></a>py37 pandas升级后提示缺少bz2</h4><blockquote>\n<p>参考 <a href=\"https://blog.csdn.net/u014589856/article/details/89175609\">解决ModuleNotFoundError: No module named &#39;_bz2&#39;</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在python3环境中默认安装的pandas包是最新的像, 像1.14.. ,而高版本的pandas0.23以后,会将bz2的引用放在头部 , 低版本的会在方法内按需引用 , 所以用高版本,会依赖bz2</span><br><span class=\"line\">需要系统级安装依赖来解决,如 yum install bzip2 libbz2-dev , 而对于已经安装好的python环境, 可以参考以下网友分享的方法, 大概步骤如下:</span><br><span class=\"line\">1  &#x2F;python36&#x2F;lib&#x2F;python3.6&#x2F;lib-dynload&#x2F;x _bz2.cpython-37m-x86_64-linux-gnu.so</span><br><span class=\"line\">2  ln -s &#x2F;usr&#x2F;lib64&#x2F;libbz2.so.1.0.6 &#x2F;usr&#x2F;lib64&#x2F;libbz2.so.1.0      </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/pandas_bz220201120_6.png\" loading=\"lazy\"></p>\n<h5 id=\"39-field-39-is-both-an-index-level-and-a-column-label-which-is-ambiguous-错误-需要重建-index\"><a href=\"#39-field-39-is-both-an-index-level-and-a-column-label-which-is-ambiguous-错误-需要重建-index\" class=\"headerlink\" title=\"&#39;field&#39; is both an index level and a column label, which is ambiguous. 错误 , 需要重建 index\"></a>&#39;field&#39; is both an index level and a column label, which is ambiguous. 错误 , 需要重建 index</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pandas0.23.1 以后版本,在pandas.merge或其它方法中会报 &#39;field&#39; is both an index level and a column label, which is ambiguous. 错误 , 需要重建 index</span><br><span class=\"line\">subfrm1 &#x3D; subfrm1.reset_index(drop&#x3D;True)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["python3.7, virtualenv , bz2"]},{"title":"BundleAnalyzer Webpack externals配置,优化chunk-vendor大小,提高初始加载速度","url":"/2021/01/25/vue-webpacket-externals/","content":"<blockquote>\n<p>调整了很多次终于见到效果 , 发现最根本的问题在于 被external的包是否依赖Vue, 如果依赖就要把Vue先加external </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">vue.config.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack-bundle-analyzer&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  publicPath: <span class=\"string\">&#x27;/saas-manager&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 只用加以下节点 , main.js当中不用调整  </span></span><br><span class=\"line\">  configureWebpack: &#123;</span><br><span class=\"line\">    externals: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用elementui 必须要先中vue(因为elementui依赖vue, 而在html文件中这两个资源也必需写在&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 之前 ),</span></span><br><span class=\"line\">      vue: <span class=\"string\">&#x27;Vue&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&#x27;element-ui&#x27;</span>: <span class=\"string\">&#x27;ELEMENT&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 更改编译输出的文件名增加hashcode , 以强制浏览器无法缓存, 保证每次修改能及时看到效果   </span></span><br><span class=\"line\">  chainWebpack: <span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    config.output.filename(<span class=\"string\">&#x27;js/[name].[hash:6].js&#x27;</span>)</span><br><span class=\"line\">    .chunkFilename(<span class=\"string\">&#x27;js/[name].[hash:6].js&#x27;</span>)</span><br><span class=\"line\">    .end();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 每次yarn serve 新开浏览器显示 BundleAnalyzer(各资源文件大小占比) </span></span><br><span class=\"line\">  config</span><br><span class=\"line\">    .plugin(<span class=\"string\">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class=\"line\">    .use(BundleAnalyzerPlugin)</span><br><span class=\"line\">    .init(<span class=\"function\">(<span class=\"params\">Plugin</span>) =&gt;</span> <span class=\"keyword\">new</span> Plugin());</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p><em>js文件未做任何调整</em> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">main.js </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ElementUI <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-ui&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&#x27;axios&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> VueAxios <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-axios&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> elementUtils <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-element-utils&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./router&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./store&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下两个资料在index.html 中引用csn资源, 以减少打包后的文件大小</span></span><br><span class=\"line\"><span class=\"comment\">// import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">// import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.productionTip = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(ElementUI, &#123;</span><br><span class=\"line\">  size: <span class=\"string\">&#x27;small&#x27;</span>,</span><br><span class=\"line\">  zIndex: <span class=\"number\">3000</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">index.html</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    // 外部css </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.14.1/theme-chalk/index.css&quot;</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  bootstrap3 会有graph,所以使用bs3   --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">// 外部js  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.14.1/index.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["BundleAnalyzer,  Webpack externals, chunk-vendor"]},{"title":"简单方法限流实现-利用缓存通道写满时写阻塞, 为空时读阻塞的特性","url":"/2021/02/19/go5-easylimiter/","content":"<h3 id=\"简单方法限流实现\"><a href=\"#简单方法限流实现\" class=\"headerlink\" title=\"简单方法限流实现\"></a>简单方法限流实现</h3><blockquote>\n<p>利用缓存通道写满时写阻塞, 为空时读阻塞的特性来实现</p>\n</blockquote>\n<h4 id=\"主要代码\"><a href=\"#主要代码\" class=\"headerlink\" title=\"主要代码\"></a>主要代码</h4><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NowTimeStr</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> DateTimePattern = <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> time.Now().Format(DateTimePattern)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ERateLimiter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tc  <span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\ttk *time.Ticker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initFill 初始的并发数 , 每秒允许的并发数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewERateLimiter</span><span class=\"params\">(initFill, requestPerSeconds <span class=\"keyword\">int</span>)</span> *<span class=\"title\">ERateLimiter</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//利用缓存通道写满时写阻塞, 为空时读阻塞的特性</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlimiter := ERateLimiter&#123;&#125;</span><br><span class=\"line\">\tconcurrency := util.Max(initFill, requestPerSeconds)</span><br><span class=\"line\">\tlimiter.c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125;, concurrency)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"number\">0</span>; i &lt; initFill; i++ &#123;</span><br><span class=\"line\">\t\tlimiter.c &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsleept := <span class=\"number\">1000</span> / requestPerSeconds</span><br><span class=\"line\">\tlimiter.tk = time.NewTicker(time.Millisecond * time.Duration(sleept))</span><br><span class=\"line\">\tlimiter.Run()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;limiter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(receiver *ERateLimiter)</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> receiver.tk.C &#123;</span><br><span class=\"line\">\t\t\treceiver.c &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(receiver *ERateLimiter)</span> <span class=\"title\">Stop</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\treceiver.tk.Stop()</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(receiver.c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(receiver *ERateLimiter)</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t&lt;-receiver.c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestERateLimiter</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tlimiter := NewERateLimiter(<span class=\"number\">10</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">50</span>; i++ &#123;</span><br><span class=\"line\">\t\tlimiter.Wait()</span><br><span class=\"line\">\t\tfmt.Println(i+<span class=\"number\">1</span>, NowTimeStr())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlimiter.Stop()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"测试输出\"><a href=\"#测试输出\" class=\"headerlink\" title=\"测试输出\"></a>测试输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x3D;&#x3D;&#x3D; RUN   TestERateLimiter</span><br><span class=\"line\">1 2021-02-19 11:56:48</span><br><span class=\"line\">2 2021-02-19 11:56:48</span><br><span class=\"line\">3 2021-02-19 11:56:48</span><br><span class=\"line\">4 2021-02-19 11:56:48</span><br><span class=\"line\">5 2021-02-19 11:56:48</span><br><span class=\"line\">6 2021-02-19 11:56:48</span><br><span class=\"line\">7 2021-02-19 11:56:48</span><br><span class=\"line\">8 2021-02-19 11:56:48</span><br><span class=\"line\">9 2021-02-19 11:56:48</span><br><span class=\"line\">10 2021-02-19 11:56:48</span><br><span class=\"line\">11 2021-02-19 11:56:48</span><br><span class=\"line\">12 2021-02-19 11:56:48</span><br><span class=\"line\">13 2021-02-19 11:56:48</span><br><span class=\"line\">14 2021-02-19 11:56:48</span><br><span class=\"line\">15 2021-02-19 11:56:48</span><br><span class=\"line\">16 2021-02-19 11:56:48</span><br><span class=\"line\">17 2021-02-19 11:56:48</span><br><span class=\"line\">18 2021-02-19 11:56:49</span><br><span class=\"line\">19 2021-02-19 11:56:49</span><br><span class=\"line\">20 2021-02-19 11:56:49</span><br><span class=\"line\">21 2021-02-19 11:56:49</span><br><span class=\"line\">22 2021-02-19 11:56:49</span><br><span class=\"line\">23 2021-02-19 11:56:49</span><br><span class=\"line\">24 2021-02-19 11:56:49</span><br><span class=\"line\">25 2021-02-19 11:56:49</span><br><span class=\"line\">26 2021-02-19 11:56:49</span><br><span class=\"line\">27 2021-02-19 11:56:49</span><br><span class=\"line\">28 2021-02-19 11:56:50</span><br><span class=\"line\">29 2021-02-19 11:56:50</span><br><span class=\"line\">30 2021-02-19 11:56:50</span><br><span class=\"line\">31 2021-02-19 11:56:50</span><br><span class=\"line\">32 2021-02-19 11:56:50</span><br><span class=\"line\">33 2021-02-19 11:56:50</span><br><span class=\"line\">34 2021-02-19 11:56:50</span><br><span class=\"line\">35 2021-02-19 11:56:50</span><br><span class=\"line\">36 2021-02-19 11:56:50</span><br><span class=\"line\">37 2021-02-19 11:56:50</span><br><span class=\"line\">38 2021-02-19 11:56:51</span><br><span class=\"line\">39 2021-02-19 11:56:51</span><br><span class=\"line\">40 2021-02-19 11:56:51</span><br><span class=\"line\">41 2021-02-19 11:56:51</span><br><span class=\"line\">42 2021-02-19 11:56:51</span><br><span class=\"line\">43 2021-02-19 11:56:51</span><br><span class=\"line\">44 2021-02-19 11:56:51</span><br><span class=\"line\">45 2021-02-19 11:56:51</span><br><span class=\"line\">46 2021-02-19 11:56:51</span><br><span class=\"line\">47 2021-02-19 11:56:51</span><br><span class=\"line\">48 2021-02-19 11:56:52</span><br><span class=\"line\">49 2021-02-19 11:56:52</span><br><span class=\"line\">50 2021-02-19 11:56:52</span><br><span class=\"line\">--- PASS: TestERateLimiter (4.00s)</span><br><span class=\"line\">PASS</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["limiter, ratelimiter"]},{"title":"effective go 简读","url":"/2021/02/22/go6-effectivego/","content":"<blockquote>\n<p>摘录自<a href=\"https://learnku.com/docs/effective-go/2020/introduction/6236\">《高效的 Go 编程 Effective Go 2020》| Go 技术论坛</a>   , 由 chrome插件简悦 · 收集合辑整理</p>\n</blockquote>\n<hr>\n<h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/introduction/6236\">引言 </a></h3><blockquote>\n<p>Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用 Go 编程在本质上就不同于其它语言。</p>\n</blockquote>\n<blockquote>\n<p>换句话说，要想将 Go 程序写得好，就必须理解其特性和风格。了解命名、格式化、 程序结构等既定规则</p>\n</blockquote>\n<hr>\n<h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/format/6237\">格式化 </a></h3><blockquote>\n<p>格式化问题总是充满了争议，但却始终没有形成统一的定论。</p>\n</blockquote>\n<blockquote>\n<p>若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范</p>\n</blockquote>\n<blockquote>\n<p>在 Go 中我们另辟蹊径，让机器来处理大部分的格式化问题。<code>gofmt</code> 程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将 Go 程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。</p>\n</blockquote>\n<blockquote>\n<p>我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。在你认为确实有必要时再使用空格。</p>\n</blockquote>\n<blockquote>\n<p>Go 对行的长度没有限制，别担心打孔纸不够长。如果一行实在太长，也可进行折行并插入适当的 tab 缩进。</p>\n</blockquote>\n<blockquote>\n<p>比起 C 和 Java，Go 所需的括号更少：控制结构（<code>if</code>、<code>for</code> 和 <code>switch</code>）在语法上并不需要圆括号。</p>\n</blockquote>\n<hr>\n<h3 id=\"代码注释\"><a href=\"#代码注释\" class=\"headerlink\" title=\"代码注释 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/code-annotation/6238\">代码注释 </a></h3><blockquote>\n<p>Go 语言支持 C 风格的块注释 <code>/* */</code> 和 C++ 风格的行注释 <code>//</code>。 行注释更为常用，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。</p>\n</blockquote>\n<blockquote>\n<p>注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，<code>godoc</code> 会像 <code>gofmt</code> 那样处理好这一切。 注释是不会被解析的纯文本</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://golang.org/pkg/fmt/\"><code>fmt</code> 包</a>的注释就用了这种不错的效果</p>\n<p>go doc fmt</p>\n</blockquote>\n<blockquote>\n<p><code>godoc</code> 既是一个程序，又是一个 Web 服务器，它对 Go 的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。</p>\n<p>参考 ftm.print包</p>\n</blockquote>\n<blockquote>\n<p>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p>\n<p>godoc -http=:6060</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Compile 用于解析正则表达式并返回，如果成</span><br><span class=\"line\">&#x2F;&#x2F; 功，则 Regexp 对象就可用于匹配所针对的文本。</span><br><span class=\"line\">func Compile(str string) (*Regexp, error) &#123;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/naming-rules/6239\">命名规则 </a></h3><blockquote>\n<p>正如命名在其它语言中的地位，它在 Go 中同样重要</p>\n</blockquote>\n<blockquote>\n<p>当一个包被导入后，包名就会成了内容的访问器。在以下代码</p>\n<p>之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了</p>\n</blockquote>\n<blockquote>\n<p>按照惯例， 包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法</p>\n</blockquote>\n<blockquote>\n<p>Go 并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 <code>Get</code> 放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为 <code>owner</code> （小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非 <code>GetOwner</code>。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，<code>SetOwner</code> 是个不错的选择。两个命名看起来都很合理：</p>\n</blockquote>\n<blockquote>\n<h3 id=\"接口命名\"><a href=\"#接口命名\" class=\"headerlink\" title=\"接口命名#\"></a>接口命名<a href=\"#e3e9b7\">#</a></h3><p>按照约定，只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名，如 <code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code> 等。</p>\n</blockquote>\n<blockquote>\n<h3 id=\"驼峰-命名\"><a href=\"#驼峰-命名\" class=\"headerlink\" title=\"驼峰 命名#\"></a>驼峰 命名<a href=\"#5b02ab\">#</a></h3><p>最后，Go 中的约定是使用 <code>MixedCaps</code> 或 <code>mixedCaps</code> 而不是下划线来编写多个单词组成的命名。</p>\n</blockquote>\n<hr>\n<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/semicolon/6240\">分号 </a></h3><blockquote>\n<p>和 C 一样，Go 的正式语法使用分号来结束语句，和 C 不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。</p>\n</blockquote>\n<blockquote>\n<p>通常 Go 程序只在诸如 <code>for</code> 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。</p>\n</blockquote>\n<blockquote>\n<p>警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code> 或 <code>select</code>）的左大括号放在下一行。</p>\n</blockquote>\n<blockquote>\n<p>Go 中的结构控制与 C 有许多相似之处，但其不同之处才是独到之处。 Go 不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的 <code>for</code>；<code>switch</code> 要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code> 一样可接受可选的初始化语句； 此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。 其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if err :&#x3D; file.Chmod(0664); err !&#x3D; nil &#123;</span><br><span class=\"line\">    log.Print(err)</span><br><span class=\"line\">    return err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>err</code> 在第一条语句中被声明，但在第二条语句中只是被<strong>再次赋值</strong>罢了。也就是说，调用 <code>f.Stat</code> 使用的是前面已经声明的 <code>err</code>，它只是被重新赋值了而已。</p>\n</blockquote>\n<blockquote>\n<p>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， <code>range</code> 子句能够帮你轻松实现循环。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sum :&#x3D; 0</span><br><span class=\"line\">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class=\"line\">    sum +&#x3D; i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在满足下列条件时，已被声明的变量 <code>v</code> 可出现在<code>:=</code> 声明中：</p>\n<ul>\n<li>  本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code> 已在外层作用域中声明过，则此次声明会创建一个新的变量 §），</li>\n<li>  在初始化中与其类型相应的值才能赋予 <code>v</code>，且</li>\n<li>  在此次声明中至少另有一个变量是新声明的。</li>\n</ul>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for key, value :&#x3D; range oldMap &#123;</span><br><span class=\"line\">    newMap[key] &#x3D; value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。 因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式 （因为它会拒绝 <code>++</code> 和 <code>--</code>）.</p>\n</blockquote>\n<blockquote>\n<p>Go 的 <code>switch</code> 比 C 的更通用。其表达式无需为常量或整数，<code>case</code> 语句会自上而下逐一进行求值直到匹配为止。若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>，因此，我们可以将 <code>if-else-if-else</code> 链写成一个 <code>switch</code>，这也更符合 Go 的风格。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func unhex(c byte) byte &#123;</span><br><span class=\"line\">    switch &#123;</span><br><span class=\"line\">    case &#39;0&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;9&#39;:</span><br><span class=\"line\">        return c - &#39;0&#39;</span><br><span class=\"line\">    case &#39;a&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;f&#39;:</span><br><span class=\"line\">        return c - &#39;a&#39; + 10</span><br><span class=\"line\">    case &#39;A&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;F&#39;:</span><br><span class=\"line\">        return c - &#39;A&#39; + 10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><code>switch</code> 并不会自动下溯，但 <code>case</code> 可通过逗号分隔来列举相同的处理条件。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func shouldEscape(c byte) bool &#123;</span><br><span class=\"line\">    switch c &#123;</span><br><span class=\"line\">    case &#39; &#39;, &#39;?&#39;, &#39;&amp;&#39;, &#39;&#x3D;&#39;, &#39;#&#39;, &#39;+&#39;, &#39;%&#39;:</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><code>switch</code> 也可用于判断接口变量的动态类型。如 <strong>类型选择</strong> 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 <code>switch</code> 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var t interface&#123;&#125;</span><br><span class=\"line\">t &#x3D; functionOfSomeType()</span><br><span class=\"line\">switch t :&#x3D; t.(type) &#123;</span><br><span class=\"line\">default:</span><br><span class=\"line\">    fmt.Printf(&quot;unexpected type %T\\n&quot;, t)     &#x2F;&#x2F; %T 打印任何类型的 t</span><br><span class=\"line\">case bool:</span><br><span class=\"line\">    fmt.Printf(&quot;boolean %t\\n&quot;, t)             &#x2F;&#x2F; t 是 bool 类型</span><br><span class=\"line\">case int:</span><br><span class=\"line\">    fmt.Printf(&quot;integer %d\\n&quot;, t)             &#x2F;&#x2F; t 是 int 类型</span><br><span class=\"line\">case *bool:</span><br><span class=\"line\">    fmt.Printf(&quot;pointer to boolean %t\\n&quot;, *t) &#x2F;&#x2F; t 是 *bool 类型</span><br><span class=\"line\">case *int:</span><br><span class=\"line\">    fmt.Printf(&quot;pointer to integer %d\\n&quot;, *t) &#x2F;&#x2F; t 是 *int 类型</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/function/6242\">函数 </a></h3><blockquote>\n<p>Go 与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善 C 中一些笨拙的习惯： 将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参。</p>\n</blockquote>\n<blockquote>\n<p>Go 函数的返回值或结果 “形参” 可被命名，并作为常规变量使用，就像传入的形参一样。 命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值； 若该函数执行了一条不带实参的 <code>return</code> 语句，则结果形参的当前值将被返回。</p>\n</blockquote>\n<blockquote>\n<p>Go 的 <code>defer</code> 语句用于预设一个函数调用（即<strong>推迟执行</strong>函数）， 该函数会在执行 <code>defer</code> 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p>\n</blockquote>\n<blockquote>\n<p>被推迟函数的实参在 <code>defer</code> 执行时才会被求值</p>\n</blockquote>\n<hr>\n<h3 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/data/6243\">数据 </a></h3><blockquote>\n<p>Go 提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code>。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单</p>\n</blockquote>\n<blockquote>\n<p><code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间， 并返回它的地址</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p :&#x3D; new(SyncedBuffer)  &#x2F;&#x2F; type *SyncedBuffer</span><br><span class=\"line\">var v SyncedBuffer      &#x2F;&#x2F; type  SyncedBuffer </span><br></pre></td></tr></table></figure>\n<p>有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func NewFile(fd int, name string) *File &#123;</span><br><span class=\"line\">    if fd &lt; 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f :&#x3D; new(File)</span><br><span class=\"line\">    f.fd &#x3D; fd</span><br><span class=\"line\">    f.name &#x3D; name</span><br><span class=\"line\">    f.dirinfo &#x3D; nil</span><br><span class=\"line\">    f.nepipe &#x3D; 0</span><br><span class=\"line\">    return f</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func NewFile(fd int, name string) *File &#123;</span><br><span class=\"line\">    if fd &lt; 0 &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class=\"line\">    return &amp;f</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>返回一个局部变量的地址完全没有问题，这点与 C 不同。该局部变量对应的数据 在函数返回后依然有效</p>\n</blockquote>\n<blockquote>\n<p>表达式 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的</p>\n</blockquote>\n<blockquote>\n<p>回到内存分配上来。内建函数 <code>make(T,</code><em>args</em><code>)</code> 的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为 <code>T</code>（而非 <code>*T</code>）的一个<strong>已初始化</strong> （而非<strong>置零</strong>）的值</p>\n</blockquote>\n<blockquote>\n<p>对于切片、映射和信道，<code>make</code> 用于初始化其内部的数据结构并准备好将要使用的值</p>\n</blockquote>\n<blockquote>\n<p>请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 <code>new</code> 分配内存。</p>\n</blockquote>\n<blockquote>\n<p>在 Go 中，</p>\n<ul>\n<li>  数组是值。将一个数组赋予另一个数组会复制其所有元素。</li>\n<li>  特别地，若将某个数组传入某个函数，它将接收到该数组的一份<strong>副本</strong>而非指针。</li>\n<li>  数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。</li>\n</ul>\n<p>数组为值的属性很有用，但代价高昂；若你想要 C 那样的行为和效率，你可以传递一个指向该数组的指针。</p>\n</blockquote>\n<blockquote>\n<p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go 中的大部分数组编程都是通过切片来完成的。</p>\n</blockquote>\n<blockquote>\n<p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针。</p>\n</blockquote>\n<blockquote>\n<p>我们必须返回切片，因为尽管 <code>Append</code> 可修改 <code>slice</code> 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p>\n</blockquote>\n<blockquote>\n<p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。</p>\n</blockquote>\n<blockquote>\n<p>映射可使用一般的复合字面语法进行构建，其键 - 值对使用冒号分隔，因此可在初始化时很容易地构建它们。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var timeZone &#x3D; map[string]int&#123;</span><br><span class=\"line\">    &quot;UTC&quot;:  0*60*60,</span><br><span class=\"line\">    &quot;EST&quot;: -5*60*60,</span><br><span class=\"line\">    &quot;CST&quot;: -6*60*60,</span><br><span class=\"line\">    &quot;MST&quot;: -7*60*60,</span><br><span class=\"line\">    &quot;PST&quot;: -8*60*60,</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。</p>\n</blockquote>\n<blockquote>\n<p>需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 <code>&quot;UTC&quot;</code> 条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var seconds int</span><br><span class=\"line\">var ok bool</span><br><span class=\"line\">seconds, ok &#x3D; timeZone[tz] </span><br></pre></td></tr></table></figure>\n<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用<a href=\"https://learnku.com/docs/effective-go/blank-identifier/6247\">空白标识符</a> （<code>_</code>）来代替该值的一般变量</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">_, present :&#x3D; timeZone[tz] </span><br></pre></td></tr></table></figure>\n<p>要删除映射中的某项，可使用内建函数 <code>delete</code>，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p>\n</blockquote>\n<blockquote>\n<p>映射中的键可能按任意顺序输出。当打印结构体时，改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名，而另一种格式 <code>%#v</code> 将完全按照 Go 的语法打印值。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&#123;7 -2.35 abc   def&#125;</span><br><span class=\"line\">&amp;&#123;a:7 b:-2.35 c:abc     def&#125;</span><br><span class=\"line\">&amp;main.T&#123;a:7, b:-2.35, c:&quot;abc\\tdef&quot;&#125;</span><br><span class=\"line\">map[string]int&#123;&quot;CST&quot;:-21600, &quot;EST&quot;:-18000, &quot;MST&quot;:-25200, &quot;PST&quot;:-28800, &quot;UTC&quot;:0&#125; </span><br></pre></td></tr></table></figure>\n<p>若你想控制自定义类型的默认格式，只需为该类型定义一个具有 <code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，可进行如下操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (t *T) String() string &#123;</span><br><span class=\"line\">    return fmt.Sprintf(&quot;%d&#x2F;%g&#x2F;%q&quot;, t.a, t.b, t.c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(&quot;%v\\n&quot;, t)</span><br></pre></td></tr></table></figure>\n<p>我们的 <code>String</code> 方法也可调用 <code>Sprintf</code>， 因为打印例程可以完全重入并按这种方式封装。不过有一个重要的细节你需要知道： 请勿通过调用 <code>Sprintf</code> 来构造 <code>String</code> 方法，因为它会无限递归你的的 <code>String</code> 方法。如果 <code>Sprintf</code> 调用试图将接收器直接打印为字符串，而该字符串又将再次调用该方法，则会发生这种情况。这是一个常见的错误，如本例所示。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type MyString string</span><br><span class=\"line\"></span><br><span class=\"line\">func (m MyString) String() string &#123;</span><br><span class=\"line\">    return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, m) &#x2F;&#x2F; 错误：会无限递归</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，它没有这个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type MyString string</span><br><span class=\"line\">func (m MyString) String() string &#123;</span><br><span class=\"line\">    return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, string(m)) &#x2F;&#x2F; 可以：注意转换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type MyString string</span><br><span class=\"line\">func (m MyString) String() string &#123;</span><br><span class=\"line\">    return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, string(m)) &#x2F;&#x2F; 可以：注意转换</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Min(a ...int) int &#123;</span><br><span class=\"line\">    min :&#x3D; int(^uint(0) &gt;&gt; 1)  &#x2F;&#x2F; 最大的 int</span><br><span class=\"line\">    for _, i :&#x3D; range a &#123;</span><br><span class=\"line\">        if i &lt; min &#123;</span><br><span class=\"line\">            min &#x3D; i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return min</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code> 那样。以下代码片段的输出与上一个相同。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class=\"line\">y :&#x3D; []int&#123;4,5,6&#125;</span><br><span class=\"line\">x &#x3D; append(x, y...)</span><br><span class=\"line\">fmt.Println(x) </span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/initialization/6244\">初始化 </a></h3><blockquote>\n<p>尽管从表面上看，Go 的初始化过程与 C 或 C++ 差别并不算太大，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p>\n</blockquote>\n<blockquote>\n<p>Go 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 <code>1&lt;&lt;3</code> 就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code> 则不是，因为对 <code>math.Sin</code> 的函数调用在运行时才会发生。</p>\n<p>可被编译器求值</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var (</span><br><span class=\"line\">    home   &#x3D; os.Getenv(&quot;HOME&quot;)</span><br><span class=\"line\">    user   &#x3D; os.Getenv(&quot;USER&quot;)</span><br><span class=\"line\">    gopath &#x3D; os.Getenv(&quot;GOPATH&quot;)</span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure>\n<p>每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用， 而包中的变量只有在所有已导入的包都被初始化后才会被求值。</p>\n</blockquote>\n<blockquote>\n<p><code>init</code> 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func init() &#123;</span><br><span class=\"line\">    if user &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class=\"line\">        log.Fatal(&quot;$USER not set&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if home &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class=\"line\">        home &#x3D; &quot;&#x2F;home&#x2F;&quot; + user</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if gopath &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class=\"line\">        gopath &#x3D; home + &quot;&#x2F;go&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; gopath 可通过命令行中的 --gopath 标记覆盖掉。</span><br><span class=\"line\">    flag.StringVar(&amp;gopath, &quot;gopath&quot;, gopath, &quot;override default GOPATH&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/method/6245\">方法 </a></h3><blockquote>\n<p>正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。</p>\n</blockquote>\n<blockquote>\n<p>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p>\n</blockquote>\n<blockquote>\n<p>之所以会有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本， 因此任何修改都将被丢弃，因此该语言不允许这种错误。</p>\n</blockquote>\n<hr>\n<h3 id=\"接口与其它类型\"><a href=\"#接口与其它类型\" class=\"headerlink\" title=\"接口与其它类型 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/interface-and-other-types/6246\">接口与其它类型 </a></h3><blockquote>\n<p>Go 中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成<strong>这个</strong>， 那么它就可以用在<strong>这里</strong></p>\n</blockquote>\n<blockquote>\n<p>是类型转换的一种形式：它接受一个接口，在选择 （switch）中根据其判断选择对应的情况（case）， 并在某种意义上将其转换为该种类型</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Stringer interface &#123;</span><br><span class=\"line\">    String() string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var value interface&#123;&#125; &#x2F;&#x2F; Value 由调用者提供</span><br><span class=\"line\">switch str :&#x3D; value.(type) &#123;</span><br><span class=\"line\">case string:</span><br><span class=\"line\">    return str</span><br><span class=\"line\">case Stringer:</span><br><span class=\"line\">    return str.String()</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str, ok :&#x3D; value.(string)</span><br><span class=\"line\">if ok &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;string value is: %q\\n&quot;, str)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;value is not a string\\n&quot;)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"空白标识符\"><a href=\"#空白标识符\" class=\"headerlink\" title=\"空白标识符 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/blank-identifier/6247\">空白标识符 </a></h3><blockquote>\n<p>我们在 <a href=\"https://learnku.com/docs/effective-go/2020/control-structure/6241#39e61d\"><code>for-range</code> 循环</a>和<a href=\"https://learnku.com/docs/effective-go/2020/data/6243#9da188\">映射</a>中提过几次空白标识符。 空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像 Unix 中的 <code>/dev/null</code> 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。 我们在前面已经见过它的用法了。</p>\n</blockquote>\n<blockquote>\n<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if _, err :&#x3D; os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;%s does not exist\\n&quot;, path)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回， 它们会提供错误的理由。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 很糟糕的代码！若路径不存在，它就会崩溃。</span><br><span class=\"line\">fi, _ :&#x3D; os.Stat(path)</span><br><span class=\"line\">if fi.IsDir() &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;%s is a directory\\n&quot;, path)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的 Bug。 然而在程序开发过程中，经常会产生未使用的导入和变量。虽然以后会用到它们， 但为了完成编译又不得不删除它们才行，这很让人烦恼。空白标识符就能提供一个工作空间。</p>\n</blockquote>\n<blockquote>\n<p>要让编译器停止关于未使用导入的包，需要空白标识符来引用已导入包中的符号。 同样，将未使用的变量 <code>fd</code> 赋予空白标识符也能关闭未使用变量错误。 该程序的以下版本可以编译。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;io&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;os&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">var _ &#x3D; fmt.Printf  &#x2F;&#x2F; 用于调试，结束时删除。</span><br><span class=\"line\">var _ io.Reader    &#x2F;&#x2F; 用于调试，结束时删除。</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    fd, err :&#x3D; os.Open(&quot;test.go&quot;)</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; TODO: use fd.</span><br><span class=\"line\">    _ &#x3D; fd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import _ &quot;net&#x2F;http&#x2F;pprof&quot; </span><br></pre></td></tr></table></figure>\n\n<p>为辅助作用导入</p>\n</blockquote>\n<blockquote>\n<p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if _, ok :&#x3D; val.(json.Marshaler); ok &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;value %v of type %T implements json.Marshaler\\n&quot;, val, val)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"内嵌\"><a href=\"#内嵌\" class=\"headerlink\" title=\"内嵌 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/embedded/6248\">内嵌 </a></h3><blockquote>\n<p>Go 并不提供典型的，类型驱动的子类化概念，但通过将类型<strong>内嵌</strong>到结构体或接口中， 它就能 “借鉴” 部分实现。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; ReadWriter 接口结合了 Reader 接口 和 Writer 接口</span><br><span class=\"line\">type ReadWriter interface &#123;</span><br><span class=\"line\">    Reader</span><br><span class=\"line\">    Writer</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><code>ReadWriter</code> 能够做任何 <code>Reader</code> <strong>和</strong> <code>Writer</code> 可以做到的事情，它是内嵌接口的联合体 （它们必须是不相交的方法集）。只有接口能被嵌入到接口中。</p>\n</blockquote>\n<blockquote>\n<p>当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 <code>bufio.ReadWriter</code> 的 <code>Read</code> 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 <code>ReadWriter</code> 的 <code>reader</code> 字段，而非 <code>ReadWriter</code> 本身。</p>\n<p>type Bank struct { sync.RWMutex saving map[string]int } func NewBank() *Bank { b := Bank{ saving: make(map[string]int), } return &amp;b } //存 func (b *Bank) Deposit(name string, amount int) { // 可以直接调用自身的Lock方法,但真实接收者是 b.RWMutex ,体现了内嵌的便利性 b.Lock() defer b.Unlock() remain, ok := b.saving[name] if !ok { b.saving[name] = amount } else { b.saving[name] = remain + amount } } //取 func (b *Bank) Withdraw(name string, amount int) int { b.Lock() defer b.Unlock() remain, ok := b.saving[name] if !ok { return 0 } if remain &lt; amount { amount = remain } b.saving[name] = remain - amount return amount } //查 func (b *Bank) Query(name string) int { b.RLock() defer b.RUnlock() amount, ok := b.saving[name] if !ok { return 0 } return amount }</p>\n</blockquote>\n<hr>\n<h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/concurrent/6249\">并发 </a></h3><blockquote>\n<p>并发编程是个很大的论题。但限于篇幅，这里仅讨论一些 Go 特有的东西。</p>\n</blockquote>\n<blockquote>\n<p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。</p>\n</blockquote>\n<blockquote>\n<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>\n</blockquote>\n<blockquote>\n<p>我们称之为 <strong>Go 协程</strong>是因为现有的术语 — 线程、协程、进程等等 — 无法准确传达它的含义。 Go 协程具有简单的模型：它是与其它 Go 协程并发运行在同一地址空间的函数。它是轻量级的， 所有消耗几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p>\n</blockquote>\n<blockquote>\n<p>Go 协程的设计隐藏了线程创建和管理的诸多复杂性。</p>\n</blockquote>\n<blockquote>\n<p>在函数或方法前添加 <code>go</code> 关键字能够在新的 Go 协程中调用它。当调用完成后， 该 Go 协程也会安静地退出。</p>\n</blockquote>\n<blockquote>\n<p>信道与映射一样，也需要通过 <code>make</code> 来分配内存。其结果值充当了对底层数据结构的引用。 若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ci :&#x3D; make(chan int)            &#x2F;&#x2F; 整数无缓冲信道</span><br><span class=\"line\">cj :&#x3D; make(chan int, 0)         &#x2F;&#x2F; 整数无缓冲信道</span><br><span class=\"line\">cs :&#x3D; make(chan *os.File, 100)  &#x2F;&#x2F; 指向文件的指针的缓冲信道 </span><br></pre></td></tr></table></figure>\n<p>若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>\n</blockquote>\n<blockquote>\n<p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 <code>handle</code>，它向信道内发送一个值，处理请求后将值从信道中取回，以便让该 “信号量” 准备迎接下一次请求。信道缓冲区的容量决定了同时调用 <code>process</code> 的数量上限，因此我们在初始化时首先要填充至它的容量上限。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var sem &#x3D; make(chan int, MaxOutstanding)</span><br><span class=\"line\"></span><br><span class=\"line\">func handle(r *Request) &#123;</span><br><span class=\"line\">    sem &lt;- 1    &#x2F;&#x2F; 等待活动队列清空。</span><br><span class=\"line\">    process(r)  &#x2F;&#x2F; 可能需要很长时间。</span><br><span class=\"line\">    &lt;-sem       &#x2F;&#x2F; 完成；使下一个请求可以运行。</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Serve(queue chan *Request) &#123;</span><br><span class=\"line\">    for &#123;</span><br><span class=\"line\">        req :&#x3D; &lt;-queue</span><br><span class=\"line\">        go handle(req)  &#x2F;&#x2F; 无需等待 handle 结束。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>Bug 出现在 Go 的 <code>for</code> 循环中，该循环变量在每次迭代时会被重用，因此 <code>req</code> 变量会在所有的 Go 协程间共享，这不是我们想要的。我们需要确保 <code>req</code> 对于每个 Go 协程来说都是唯一的。有一种方法能够做到，就是将 <code>req</code> 的值作为实参传入到该 Go 协程的闭包中：</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Serve(queue chan *Request) &#123;</span><br><span class=\"line\">    for req :&#x3D; range queue &#123;</span><br><span class=\"line\">        sem &lt;- 1</span><br><span class=\"line\">        go func(req *Request) &#123;</span><br><span class=\"line\">            process(req)</span><br><span class=\"line\">            &lt;-sem</span><br><span class=\"line\">        &#125;(req)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的 <code>handle</code> Go 协程，一起从请求信道中读取数据。Go 协程的数量限制了同时调用 <code>process</code> 的数量。<code>Serve</code> 同样会接收一个通知退出的信道， 在启动所有 Go 协程后，它将阻塞并暂停从信道中接收消息。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func handle(queue chan *Request) &#123;</span><br><span class=\"line\">    for r :&#x3D; range queue &#123;</span><br><span class=\"line\">        process(r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Serve(clientRequests chan *Request, quit chan bool) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 启动处理程序</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; MaxOutstanding; i++ &#123;</span><br><span class=\"line\">        go handle(clientRequests)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;-quit  &#x2F;&#x2F; 等待通知退出。</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>这些设计的另一个应用是在多 CPU 核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p>\n</blockquote>\n<blockquote>\n<p>我们在循环中启动了独立的处理块，每个 CPU 将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有 Go 协程开始后接收，并统计信道中的完成信号即可。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const numCPU &#x3D; 4 &#x2F;&#x2F; CPU 核心数</span><br><span class=\"line\"></span><br><span class=\"line\">func (v Vector) DoAll(u Vector) &#123;</span><br><span class=\"line\">    c :&#x3D; make(chan int, numCPU)  &#x2F;&#x2F; 缓冲区是可选的，但明显用上更好</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; numCPU; i++ &#123;</span><br><span class=\"line\">        go v.DoSome(i*len(v)&#x2F;numCPU, (i+1)*len(v)&#x2F;numCPU, u, c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 排空信道。</span><br><span class=\"line\">    for i :&#x3D; 0; i &lt; numCPU; i++ &#123;</span><br><span class=\"line\">        &lt;-c    &#x2F;&#x2F; 等待任务完成</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 一切完成</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var numCPU &#x3D; runtime.NumCPU() </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var numCPU &#x3D; runtime.GOMAXPROCS(0) </span><br></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误 \"></a><a href=\"https://learnku.com/docs/effective-go/2020/error/6250\">错误 </a></h3><blockquote>\n<p>库函数很多时候必须将错误信息返回给函数的调用者。如前所述，Go 允许函数可以有多个返回值的特性，使得函数的调用者在得到正常返回值的同时，可以获取到更为详细的错误信息</p>\n</blockquote>\n<blockquote>\n<p>按照约定，错误的类型通常为 <code>error</code>，这是一个内置的简单接口。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。比如 <code>PathErrors</code>，它你可能会想检查内部的 <code>Err</code> 字段来判断这是否是一个可以被恢复的错误。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for try :&#x3D; 0; try &lt; 2; try++ &#123;</span><br><span class=\"line\">    file, err &#x3D; os.Create(filename)</span><br><span class=\"line\">    if err &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if e, ok :&#x3D; err.(*os.PathError); ok &amp;&amp; e.Err &#x3D;&#x3D; syscall.ENOSPC &#123;</span><br><span class=\"line\">        deleteTempFiles()  &#x2F;&#x2F; 恢复一些空间。</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var user &#x3D; os.Getenv(&quot;USER&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">func init() &#123;</span><br><span class=\"line\">    if user &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class=\"line\">        panic(&quot;no value for $USER&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>当 <code>panic</code> 被调用后（包括不明确的运行时错误，例如切片越界访问或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯 Go 协程的栈，运行任何被推迟的函数。 若回溯到达 Go 协程栈的顶端，程序就会终止。不过我们可以用内建的 <code>recover</code> 函数来重新或来取回 Go 协程的控制权限并使其恢复正常执行。</p>\n<p>调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此 <code>recover</code> 只能在被推迟的函数中才有效。</p>\n</blockquote>\n","tags":["effective, go预览"]},{"url":"/css/custom.css","content":"@media screen and (min-width: 1280px) {\n    .container {\n        max-width: 1400px !important;\n    }\n\n\n    .column.is-3-widescreen {\n        flex: none;\n        width: 15% !important;\n    }\n\n    .column.is-3-widescreen {\n        flex: none;\n        width: 15% !important;\n    }\n\n    .column.is-6-widescreen {\n        flex: none;\n        width: 70% !important ;\n    }\n}\n\n"},{"title":"tags","url":"/tags/index.html","content":""}]