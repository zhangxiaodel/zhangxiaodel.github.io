<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>run coder</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="run coder"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="run coder"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="run coder"><meta property="og:url" content="http://zhangxiaodel.github.io/"><meta property="og:site_name" content="run coder"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://zhangxiaodel.github.io/img/og_image.png"><meta property="article:author" content="zhangxiaodel"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zhangxiaodel.github.io"},"headline":"run coder","image":["http://zhangxiaodel.github.io/img/og_image.png"],"author":{"@type":"Person","name":"zhangxiaodel"},"description":null}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="run coder" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">run coder</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zhangxiaodel"><i class="fab fa-github"></i></a></div></div></div></nav><section class="section"><div class="container" style="width:100% !important;"><div class="columns"><div class="column order-2 column-main" style="width:60% !important"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-22T10:34:55.000Z" title="2/22/2021, 6:34:55 PM">2021-02-22</time>发表</span><span class="level-item"><time dateTime="2021-02-22T10:36:16.307Z" title="2/22/2021, 6:36:16 PM">2021-02-22</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/22/go6-effectivego/">effective go 简读</a></h1><div class="content"><blockquote>
<p>摘录自<a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/introduction/6236">《高效的 Go 编程 Effective Go 2020》| Go 技术论坛</a>   , 由 chrome插件简悦 · 收集合辑整理</p>
</blockquote>
<hr>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/introduction/6236">引言 </a></h3><blockquote>
<p>Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性， 使得使用 Go 编程在本质上就不同于其它语言。</p>
</blockquote>
<blockquote>
<p>换句话说，要想将 Go 程序写得好，就必须理解其特性和风格。了解命名、格式化、 程序结构等既定规则</p>
</blockquote>
<hr>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/format/6237">格式化 </a></h3><blockquote>
<p>格式化问题总是充满了争议，但却始终没有形成统一的定论。</p>
</blockquote>
<blockquote>
<p>若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。 问题就在于如何实现这种设想，而无需冗长的语言风格规范</p>
</blockquote>
<blockquote>
<p>在 Go 中我们另辟蹊径，让机器来处理大部分的格式化问题。<code>gofmt</code> 程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将 Go 程序按照标准风格缩进、 对齐，保留注释并在需要时重新格式化。</p>
</blockquote>
<blockquote>
<p>我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。在你认为确实有必要时再使用空格。</p>
</blockquote>
<blockquote>
<p>Go 对行的长度没有限制，别担心打孔纸不够长。如果一行实在太长，也可进行折行并插入适当的 tab 缩进。</p>
</blockquote>
<blockquote>
<p>比起 C 和 Java，Go 所需的括号更少：控制结构（<code>if</code>、<code>for</code> 和 <code>switch</code>）在语法上并不需要圆括号。</p>
</blockquote>
<hr>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/code-annotation/6238">代码注释 </a></h3><blockquote>
<p>Go 语言支持 C 风格的块注释 <code>/* */</code> 和 C++ 风格的行注释 <code>//</code>。 行注释更为常用，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。</p>
</blockquote>
<blockquote>
<p>注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示， 因此不要依赖于空格对齐，<code>godoc</code> 会像 <code>gofmt</code> 那样处理好这一切。 注释是不会被解析的纯文本</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://golang.org/pkg/fmt/"><code>fmt</code> 包</a>的注释就用了这种不错的效果</p>
<p>go doc fmt</p>
</blockquote>
<blockquote>
<p><code>godoc</code> 既是一个程序，又是一个 Web 服务器，它对 Go 的源码进行处理，并提取包中的文档内容。 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。</p>
<p>参考 ftm.print包</p>
</blockquote>
<blockquote>
<p>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p>
<p>godoc -http=:6060</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Compile 用于解析正则表达式并返回，如果成</span><br><span class="line">&#x2F;&#x2F; 功，则 Regexp 对象就可用于匹配所针对的文本。</span><br><span class="line">func Compile(str string) (*Regexp, error) &#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/naming-rules/6239">命名规则 </a></h3><blockquote>
<p>正如命名在其它语言中的地位，它在 Go 中同样重要</p>
</blockquote>
<blockquote>
<p>当一个包被导入后，包名就会成了内容的访问器。在以下代码</p>
<p>之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了</p>
</blockquote>
<blockquote>
<p>按照惯例， 包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法</p>
</blockquote>
<blockquote>
<p>Go 并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 <code>Get</code> 放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为 <code>owner</code> （小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非 <code>GetOwner</code>。大写字母即为可导出的这种规定为区分方法和字段提供了便利。 若要提供设置器方法，<code>SetOwner</code> 是个不错的选择。两个命名看起来都很合理：</p>
</blockquote>
<blockquote>
<h3 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名#"></a>接口命名<a href="#e3e9b7">#</a></h3><p>按照约定，只包含一个方法的接口应当以该方法的名称加上 - er 后缀来命名，如 <code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code> 等。</p>
</blockquote>
<blockquote>
<h3 id="驼峰-命名"><a href="#驼峰-命名" class="headerlink" title="驼峰 命名#"></a>驼峰 命名<a href="#5b02ab">#</a></h3><p>最后，Go 中的约定是使用 <code>MixedCaps</code> 或 <code>mixedCaps</code> 而不是下划线来编写多个单词组成的命名。</p>
</blockquote>
<hr>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/semicolon/6240">分号 </a></h3><blockquote>
<p>和 C 一样，Go 的正式语法使用分号来结束语句，和 C 不同的是，这些分号并不在源码中出现。 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。</p>
</blockquote>
<blockquote>
<p>通常 Go 程序只在诸如 <code>for</code> 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。</p>
</blockquote>
<blockquote>
<p>警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code> 或 <code>select</code>）的左大括号放在下一行。</p>
</blockquote>
<blockquote>
<p>Go 中的结构控制与 C 有许多相似之处，但其不同之处才是独到之处。 Go 不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的 <code>for</code>；<code>switch</code> 要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code> 一样可接受可选的初始化语句； 此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。 其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err :&#x3D; file.Chmod(0664); err !&#x3D; nil &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>err</code> 在第一条语句中被声明，但在第二条语句中只是被<strong>再次赋值</strong>罢了。也就是说，调用 <code>f.Stat</code> 使用的是前面已经声明的 <code>err</code>，它只是被重新赋值了而已。</p>
</blockquote>
<blockquote>
<p>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， <code>range</code> 子句能够帮你轻松实现循环。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum :&#x3D; 0</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">    sum +&#x3D; i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在满足下列条件时，已被声明的变量 <code>v</code> 可出现在<code>:=</code> 声明中：</p>
<ul>
<li>  本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code> 已在外层作用域中声明过，则此次声明会创建一个新的变量 §），</li>
<li>  在初始化中与其类型相应的值才能赋予 <code>v</code>，且</li>
<li>  在此次声明中至少另有一个变量是新声明的。</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value :&#x3D; range oldMap &#123;</span><br><span class="line">    newMap[key] &#x3D; value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。 因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式 （因为它会拒绝 <code>++</code> 和 <code>--</code>）.</p>
</blockquote>
<blockquote>
<p>Go 的 <code>switch</code> 比 C 的更通用。其表达式无需为常量或整数，<code>case</code> 语句会自上而下逐一进行求值直到匹配为止。若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>，因此，我们可以将 <code>if-else-if-else</code> 链写成一个 <code>switch</code>，这也更符合 Go 的风格。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func unhex(c byte) byte &#123;</span><br><span class="line">    switch &#123;</span><br><span class="line">    case &#39;0&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;9&#39;:</span><br><span class="line">        return c - &#39;0&#39;</span><br><span class="line">    case &#39;a&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;f&#39;:</span><br><span class="line">        return c - &#39;a&#39; + 10</span><br><span class="line">    case &#39;A&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;F&#39;:</span><br><span class="line">        return c - &#39;A&#39; + 10</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>switch</code> 并不会自动下溯，但 <code>case</code> 可通过逗号分隔来列举相同的处理条件。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func shouldEscape(c byte) bool &#123;</span><br><span class="line">    switch c &#123;</span><br><span class="line">    case &#39; &#39;, &#39;?&#39;, &#39;&amp;&#39;, &#39;&#x3D;&#39;, &#39;#&#39;, &#39;+&#39;, &#39;%&#39;:</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>switch</code> 也可用于判断接口变量的动态类型。如 <strong>类型选择</strong> 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 <code>switch</code> 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var t interface&#123;&#125;</span><br><span class="line">t &#x3D; functionOfSomeType()</span><br><span class="line">switch t :&#x3D; t.(type) &#123;</span><br><span class="line">default:</span><br><span class="line">    fmt.Printf(&quot;unexpected type %T\n&quot;, t)     &#x2F;&#x2F; %T 打印任何类型的 t</span><br><span class="line">case bool:</span><br><span class="line">    fmt.Printf(&quot;boolean %t\n&quot;, t)             &#x2F;&#x2F; t 是 bool 类型</span><br><span class="line">case int:</span><br><span class="line">    fmt.Printf(&quot;integer %d\n&quot;, t)             &#x2F;&#x2F; t 是 int 类型</span><br><span class="line">case *bool:</span><br><span class="line">    fmt.Printf(&quot;pointer to boolean %t\n&quot;, *t) &#x2F;&#x2F; t 是 *bool 类型</span><br><span class="line">case *int:</span><br><span class="line">    fmt.Printf(&quot;pointer to integer %d\n&quot;, *t) &#x2F;&#x2F; t 是 *int 类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/function/6242">函数 </a></h3><blockquote>
<p>Go 与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善 C 中一些笨拙的习惯： 将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参。</p>
</blockquote>
<blockquote>
<p>Go 函数的返回值或结果 “形参” 可被命名，并作为常规变量使用，就像传入的形参一样。 命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值； 若该函数执行了一条不带实参的 <code>return</code> 语句，则结果形参的当前值将被返回。</p>
</blockquote>
<blockquote>
<p>Go 的 <code>defer</code> 语句用于预设一个函数调用（即<strong>推迟执行</strong>函数）， 该函数会在执行 <code>defer</code> 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p>
</blockquote>
<blockquote>
<p>被推迟函数的实参在 <code>defer</code> 执行时才会被求值</p>
</blockquote>
<hr>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/data/6243">数据 </a></h3><blockquote>
<p>Go 提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code>。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单</p>
</blockquote>
<blockquote>
<p><code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间， 并返回它的地址</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p :&#x3D; new(SyncedBuffer)  &#x2F;&#x2F; type *SyncedBuffer</span><br><span class="line">var v SyncedBuffer      &#x2F;&#x2F; type  SyncedBuffer </span><br></pre></td></tr></table></figure>
<p>有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f :&#x3D; new(File)</span><br><span class="line">    f.fd &#x3D; fd</span><br><span class="line">    f.name &#x3D; name</span><br><span class="line">    f.dirinfo &#x3D; nil</span><br><span class="line">    f.nepipe &#x3D; 0</span><br><span class="line">    return f</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    f :&#x3D; File&#123;fd, name, nil, 0&#125;</span><br><span class="line">    return &amp;f</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>返回一个局部变量的地址完全没有问题，这点与 C 不同。该局部变量对应的数据 在函数返回后依然有效</p>
</blockquote>
<blockquote>
<p>表达式 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的</p>
</blockquote>
<blockquote>
<p>回到内存分配上来。内建函数 <code>make(T,</code><em>args</em><code>)</code> 的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为 <code>T</code>（而非 <code>*T</code>）的一个<strong>已初始化</strong> （而非<strong>置零</strong>）的值</p>
</blockquote>
<blockquote>
<p>对于切片、映射和信道，<code>make</code> 用于初始化其内部的数据结构并准备好将要使用的值</p>
</blockquote>
<blockquote>
<p>请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 <code>new</code> 分配内存。</p>
</blockquote>
<blockquote>
<p>在 Go 中，</p>
<ul>
<li>  数组是值。将一个数组赋予另一个数组会复制其所有元素。</li>
<li>  特别地，若将某个数组传入某个函数，它将接收到该数组的一份<strong>副本</strong>而非指针。</li>
<li>  数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。</li>
</ul>
<p>数组为值的属性很有用，但代价高昂；若你想要 C 那样的行为和效率，你可以传递一个指向该数组的指针。</p>
</blockquote>
<blockquote>
<p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go 中的大部分数组编程都是通过切片来完成的。</p>
</blockquote>
<blockquote>
<p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针。</p>
</blockquote>
<blockquote>
<p>我们必须返回切片，因为尽管 <code>Append</code> 可修改 <code>slice</code> 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p>
</blockquote>
<blockquote>
<p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。</p>
</blockquote>
<blockquote>
<p>映射可使用一般的复合字面语法进行构建，其键 - 值对使用冒号分隔，因此可在初始化时很容易地构建它们。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var timeZone &#x3D; map[string]int&#123;</span><br><span class="line">    &quot;UTC&quot;:  0*60*60,</span><br><span class="line">    &quot;EST&quot;: -5*60*60,</span><br><span class="line">    &quot;CST&quot;: -6*60*60,</span><br><span class="line">    &quot;MST&quot;: -7*60*60,</span><br><span class="line">    &quot;PST&quot;: -8*60*60,</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。</p>
</blockquote>
<blockquote>
<p>需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 <code>&quot;UTC&quot;</code> 条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var seconds int</span><br><span class="line">var ok bool</span><br><span class="line">seconds, ok &#x3D; timeZone[tz] </span><br></pre></td></tr></table></figure>
<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用<a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/blank-identifier/6247">空白标识符</a> （<code>_</code>）来代替该值的一般变量</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present :&#x3D; timeZone[tz] </span><br></pre></td></tr></table></figure>
<p>要删除映射中的某项，可使用内建函数 <code>delete</code>，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p>
</blockquote>
<blockquote>
<p>映射中的键可能按任意顺序输出。当打印结构体时，改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名，而另一种格式 <code>%#v</code> 将完全按照 Go 的语法打印值。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;7 -2.35 abc   def&#125;</span><br><span class="line">&amp;&#123;a:7 b:-2.35 c:abc     def&#125;</span><br><span class="line">&amp;main.T&#123;a:7, b:-2.35, c:&quot;abc\tdef&quot;&#125;</span><br><span class="line">map[string]int&#123;&quot;CST&quot;:-21600, &quot;EST&quot;:-18000, &quot;MST&quot;:-25200, &quot;PST&quot;:-28800, &quot;UTC&quot;:0&#125; </span><br></pre></td></tr></table></figure>
<p>若你想控制自定义类型的默认格式，只需为该类型定义一个具有 <code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，可进行如下操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (t *T) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;%d&#x2F;%g&#x2F;%q&quot;, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, t)</span><br></pre></td></tr></table></figure>
<p>我们的 <code>String</code> 方法也可调用 <code>Sprintf</code>， 因为打印例程可以完全重入并按这种方式封装。不过有一个重要的细节你需要知道： 请勿通过调用 <code>Sprintf</code> 来构造 <code>String</code> 方法，因为它会无限递归你的的 <code>String</code> 方法。如果 <code>Sprintf</code> 调用试图将接收器直接打印为字符串，而该字符串又将再次调用该方法，则会发生这种情况。这是一个常见的错误，如本例所示。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line"></span><br><span class="line">func (m MyString) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, m) &#x2F;&#x2F; 错误：会无限递归</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，它没有这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">func (m MyString) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, string(m)) &#x2F;&#x2F; 可以：注意转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type MyString string</span><br><span class="line">func (m MyString) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;MyString&#x3D;%s&quot;, string(m)) &#x2F;&#x2F; 可以：注意转换</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Min(a ...int) int &#123;</span><br><span class="line">    min :&#x3D; int(^uint(0) &gt;&gt; 1)  &#x2F;&#x2F; 最大的 int</span><br><span class="line">    for _, i :&#x3D; range a &#123;</span><br><span class="line">        if i &lt; min &#123;</span><br><span class="line">            min &#x3D; i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code> 那样。以下代码片段的输出与上一个相同。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x :&#x3D; []int&#123;1,2,3&#125;</span><br><span class="line">y :&#x3D; []int&#123;4,5,6&#125;</span><br><span class="line">x &#x3D; append(x, y...)</span><br><span class="line">fmt.Println(x) </span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/initialization/6244">初始化 </a></h3><blockquote>
<p>尽管从表面上看，Go 的初始化过程与 C 或 C++ 差别并不算太大，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p>
</blockquote>
<blockquote>
<p>Go 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 <code>1&lt;&lt;3</code> 就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code> 则不是，因为对 <code>math.Sin</code> 的函数调用在运行时才会发生。</p>
<p>可被编译器求值</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    home   &#x3D; os.Getenv(&quot;HOME&quot;)</span><br><span class="line">    user   &#x3D; os.Getenv(&quot;USER&quot;)</span><br><span class="line">    gopath &#x3D; os.Getenv(&quot;GOPATH&quot;)</span><br><span class="line">) </span><br></pre></td></tr></table></figure>
<p>每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用， 而包中的变量只有在所有已导入的包都被初始化后才会被求值。</p>
</blockquote>
<blockquote>
<p><code>init</code> 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">    if user &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">        log.Fatal(&quot;$USER not set&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if home &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">        home &#x3D; &quot;&#x2F;home&#x2F;&quot; + user</span><br><span class="line">    &#125;</span><br><span class="line">    if gopath &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">        gopath &#x3D; home + &quot;&#x2F;go&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; gopath 可通过命令行中的 --gopath 标记覆盖掉。</span><br><span class="line">    flag.StringVar(&amp;gopath, &quot;gopath&quot;, gopath, &quot;override default GOPATH&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/method/6245">方法 </a></h3><blockquote>
<p>正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。</p>
</blockquote>
<blockquote>
<p>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p>
</blockquote>
<blockquote>
<p>之所以会有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本， 因此任何修改都将被丢弃，因此该语言不允许这种错误。</p>
</blockquote>
<hr>
<h3 id="接口与其它类型"><a href="#接口与其它类型" class="headerlink" title="接口与其它类型 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/interface-and-other-types/6246">接口与其它类型 </a></h3><blockquote>
<p>Go 中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成<strong>这个</strong>， 那么它就可以用在<strong>这里</strong></p>
</blockquote>
<blockquote>
<p>是类型转换的一种形式：它接受一个接口，在选择 （switch）中根据其判断选择对应的情况（case）， 并在某种意义上将其转换为该种类型</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var value interface&#123;&#125; &#x2F;&#x2F; Value 由调用者提供</span><br><span class="line">switch str :&#x3D; value.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">    return str</span><br><span class="line">case Stringer:</span><br><span class="line">    return str.String()</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok :&#x3D; value.(string)</span><br><span class="line">if ok &#123;</span><br><span class="line">    fmt.Printf(&quot;string value is: %q\n&quot;, str)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fmt.Printf(&quot;value is not a string\n&quot;)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/blank-identifier/6247">空白标识符 </a></h3><blockquote>
<p>我们在 <a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/control-structure/6241#39e61d"><code>for-range</code> 循环</a>和<a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/data/6243#9da188">映射</a>中提过几次空白标识符。 空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像 Unix 中的 <code>/dev/null</code> 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。 我们在前面已经见过它的用法了。</p>
</blockquote>
<blockquote>
<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if _, err :&#x3D; os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">    fmt.Printf(&quot;%s does not exist\n&quot;, path)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回， 它们会提供错误的理由。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 很糟糕的代码！若路径不存在，它就会崩溃。</span><br><span class="line">fi, _ :&#x3D; os.Stat(path)</span><br><span class="line">if fi.IsDir() &#123;</span><br><span class="line">    fmt.Printf(&quot;%s is a directory\n&quot;, path)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的 Bug。 然而在程序开发过程中，经常会产生未使用的导入和变量。虽然以后会用到它们， 但为了完成编译又不得不删除它们才行，这很让人烦恼。空白标识符就能提供一个工作空间。</p>
</blockquote>
<blockquote>
<p>要让编译器停止关于未使用导入的包，需要空白标识符来引用已导入包中的符号。 同样，将未使用的变量 <code>fd</code> 赋予空白标识符也能关闭未使用变量错误。 该程序的以下版本可以编译。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var _ &#x3D; fmt.Printf  &#x2F;&#x2F; 用于调试，结束时删除。</span><br><span class="line">var _ io.Reader    &#x2F;&#x2F; 用于调试，结束时删除。</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fd, err :&#x3D; os.Open(&quot;test.go&quot;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; TODO: use fd.</span><br><span class="line">    _ &#x3D; fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;net&#x2F;http&#x2F;pprof&quot; </span><br></pre></td></tr></table></figure>

<p>为辅助作用导入</p>
</blockquote>
<blockquote>
<p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if _, ok :&#x3D; val.(json.Marshaler); ok &#123;</span><br><span class="line">    fmt.Printf(&quot;value %v of type %T implements json.Marshaler\n&quot;, val, val)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/embedded/6248">内嵌 </a></h3><blockquote>
<p>Go 并不提供典型的，类型驱动的子类化概念，但通过将类型<strong>内嵌</strong>到结构体或接口中， 它就能 “借鉴” 部分实现。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ReadWriter 接口结合了 Reader 接口 和 Writer 接口</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>ReadWriter</code> 能够做任何 <code>Reader</code> <strong>和</strong> <code>Writer</code> 可以做到的事情，它是内嵌接口的联合体 （它们必须是不相交的方法集）。只有接口能被嵌入到接口中。</p>
</blockquote>
<blockquote>
<p>当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 <code>bufio.ReadWriter</code> 的 <code>Read</code> 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 <code>ReadWriter</code> 的 <code>reader</code> 字段，而非 <code>ReadWriter</code> 本身。</p>
<p>type Bank struct { sync.RWMutex saving map[string]int } func NewBank() *Bank { b := Bank{ saving: make(map[string]int), } return &amp;b } //存 func (b *Bank) Deposit(name string, amount int) { // 可以直接调用自身的Lock方法,但真实接收者是 b.RWMutex ,体现了内嵌的便利性 b.Lock() defer b.Unlock() remain, ok := b.saving[name] if !ok { b.saving[name] = amount } else { b.saving[name] = remain + amount } } //取 func (b *Bank) Withdraw(name string, amount int) int { b.Lock() defer b.Unlock() remain, ok := b.saving[name] if !ok { return 0 } if remain &lt; amount { amount = remain } b.saving[name] = remain - amount return amount } //查 func (b *Bank) Query(name string) int { b.RLock() defer b.RUnlock() amount, ok := b.saving[name] if !ok { return 0 } return amount }</p>
</blockquote>
<hr>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/concurrent/6249">并发 </a></h3><blockquote>
<p>并发编程是个很大的论题。但限于篇幅，这里仅讨论一些 Go 特有的东西。</p>
</blockquote>
<blockquote>
<p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。</p>
</blockquote>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<blockquote>
<p>我们称之为 <strong>Go 协程</strong>是因为现有的术语 — 线程、协程、进程等等 — 无法准确传达它的含义。 Go 协程具有简单的模型：它是与其它 Go 协程并发运行在同一地址空间的函数。它是轻量级的， 所有消耗几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p>
</blockquote>
<blockquote>
<p>Go 协程的设计隐藏了线程创建和管理的诸多复杂性。</p>
</blockquote>
<blockquote>
<p>在函数或方法前添加 <code>go</code> 关键字能够在新的 Go 协程中调用它。当调用完成后， 该 Go 协程也会安静地退出。</p>
</blockquote>
<blockquote>
<p>信道与映射一样，也需要通过 <code>make</code> 来分配内存。其结果值充当了对底层数据结构的引用。 若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci :&#x3D; make(chan int)            &#x2F;&#x2F; 整数无缓冲信道</span><br><span class="line">cj :&#x3D; make(chan int, 0)         &#x2F;&#x2F; 整数无缓冲信道</span><br><span class="line">cs :&#x3D; make(chan *os.File, 100)  &#x2F;&#x2F; 指向文件的指针的缓冲信道 </span><br></pre></td></tr></table></figure>
<p>若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>
</blockquote>
<blockquote>
<p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 <code>handle</code>，它向信道内发送一个值，处理请求后将值从信道中取回，以便让该 “信号量” 准备迎接下一次请求。信道缓冲区的容量决定了同时调用 <code>process</code> 的数量上限，因此我们在初始化时首先要填充至它的容量上限。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var sem &#x3D; make(chan int, MaxOutstanding)</span><br><span class="line"></span><br><span class="line">func handle(r *Request) &#123;</span><br><span class="line">    sem &lt;- 1    &#x2F;&#x2F; 等待活动队列清空。</span><br><span class="line">    process(r)  &#x2F;&#x2F; 可能需要很长时间。</span><br><span class="line">    &lt;-sem       &#x2F;&#x2F; 完成；使下一个请求可以运行。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Serve(queue chan *Request) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        req :&#x3D; &lt;-queue</span><br><span class="line">        go handle(req)  &#x2F;&#x2F; 无需等待 handle 结束。</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Bug 出现在 Go 的 <code>for</code> 循环中，该循环变量在每次迭代时会被重用，因此 <code>req</code> 变量会在所有的 Go 协程间共享，这不是我们想要的。我们需要确保 <code>req</code> 对于每个 Go 协程来说都是唯一的。有一种方法能够做到，就是将 <code>req</code> 的值作为实参传入到该 Go 协程的闭包中：</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Serve(queue chan *Request) &#123;</span><br><span class="line">    for req :&#x3D; range queue &#123;</span><br><span class="line">        sem &lt;- 1</span><br><span class="line">        go func(req *Request) &#123;</span><br><span class="line">            process(req)</span><br><span class="line">            &lt;-sem</span><br><span class="line">        &#125;(req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的 <code>handle</code> Go 协程，一起从请求信道中读取数据。Go 协程的数量限制了同时调用 <code>process</code> 的数量。<code>Serve</code> 同样会接收一个通知退出的信道， 在启动所有 Go 协程后，它将阻塞并暂停从信道中接收消息。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func handle(queue chan *Request) &#123;</span><br><span class="line">    for r :&#x3D; range queue &#123;</span><br><span class="line">        process(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Serve(clientRequests chan *Request, quit chan bool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动处理程序</span><br><span class="line">    for i :&#x3D; 0; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">        go handle(clientRequests)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-quit  &#x2F;&#x2F; 等待通知退出。</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这些设计的另一个应用是在多 CPU 核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p>
</blockquote>
<blockquote>
<p>我们在循环中启动了独立的处理块，每个 CPU 将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有 Go 协程开始后接收，并统计信道中的完成信号即可。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const numCPU &#x3D; 4 &#x2F;&#x2F; CPU 核心数</span><br><span class="line"></span><br><span class="line">func (v Vector) DoAll(u Vector) &#123;</span><br><span class="line">    c :&#x3D; make(chan int, numCPU)  &#x2F;&#x2F; 缓冲区是可选的，但明显用上更好</span><br><span class="line">    for i :&#x3D; 0; i &lt; numCPU; i++ &#123;</span><br><span class="line">        go v.DoSome(i*len(v)&#x2F;numCPU, (i+1)*len(v)&#x2F;numCPU, u, c)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 排空信道。</span><br><span class="line">    for i :&#x3D; 0; i &lt; numCPU; i++ &#123;</span><br><span class="line">        &lt;-c    &#x2F;&#x2F; 等待任务完成</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 一切完成</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numCPU &#x3D; runtime.NumCPU() </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numCPU &#x3D; runtime.GOMAXPROCS(0) </span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误 "></a><a target="_blank" rel="noopener" href="https://learnku.com/docs/effective-go/2020/error/6250">错误 </a></h3><blockquote>
<p>库函数很多时候必须将错误信息返回给函数的调用者。如前所述，Go 允许函数可以有多个返回值的特性，使得函数的调用者在得到正常返回值的同时，可以获取到更为详细的错误信息</p>
</blockquote>
<blockquote>
<p>按照约定，错误的类型通常为 <code>error</code>，这是一个内置的简单接口。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。比如 <code>PathErrors</code>，它你可能会想检查内部的 <code>Err</code> 字段来判断这是否是一个可以被恢复的错误。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for try :&#x3D; 0; try &lt; 2; try++ &#123;</span><br><span class="line">    file, err &#x3D; os.Create(filename)</span><br><span class="line">    if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if e, ok :&#x3D; err.(*os.PathError); ok &amp;&amp; e.Err &#x3D;&#x3D; syscall.ENOSPC &#123;</span><br><span class="line">        deleteTempFiles()  &#x2F;&#x2F; 恢复一些空间。</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var user &#x3D; os.Getenv(&quot;USER&quot;)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">    if user &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">        panic(&quot;no value for $USER&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>当 <code>panic</code> 被调用后（包括不明确的运行时错误，例如切片越界访问或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯 Go 协程的栈，运行任何被推迟的函数。 若回溯到达 Go 协程栈的顶端，程序就会终止。不过我们可以用内建的 <code>recover</code> 函数来重新或来取回 Go 协程的控制权限并使其恢复正常执行。</p>
<p>调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此 <code>recover</code> 只能在被推迟的函数中才有效。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T03:52:10.000Z" title="2/19/2021, 11:52:10 AM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T03:57:33.553Z" title="2/19/2021, 11:57:33 AM">2021-02-19</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/go5-easylimiter/">简单方法限流实现-利用缓存通道写满时写阻塞, 为空时读阻塞的特性</a></h1><div class="content"><h3 id="简单方法限流实现"><a href="#简单方法限流实现" class="headerlink" title="简单方法限流实现"></a>简单方法限流实现</h3><blockquote>
<p>利用缓存通道写满时写阻塞, 为空时读阻塞的特性来实现</p>
</blockquote>
<h4 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NowTimeStr</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> DateTimePattern = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">	<span class="keyword">return</span> time.Now().Format(DateTimePattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ERateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	c  <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	tk *time.Ticker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initFill 初始的并发数 , 每秒允许的并发数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewERateLimiter</span><span class="params">(initFill, requestPerSeconds <span class="keyword">int</span>)</span> *<span class="title">ERateLimiter</span></span> &#123;</span><br><span class="line">	<span class="comment">//利用缓存通道写满时写阻塞, 为空时读阻塞的特性</span></span><br><span class="line"></span><br><span class="line">	limiter := ERateLimiter&#123;&#125;</span><br><span class="line">	concurrency := util.Max(initFill, requestPerSeconds)</span><br><span class="line">	limiter.c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, concurrency)</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; initFill; i++ &#123;</span><br><span class="line">		limiter.c &lt;- <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	sleept := <span class="number">1000</span> / requestPerSeconds</span><br><span class="line">	limiter.tk = time.NewTicker(time.Millisecond * time.Duration(sleept))</span><br><span class="line">	limiter.Run()</span><br><span class="line">	<span class="keyword">return</span> &amp;limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *ERateLimiter)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="keyword">range</span> receiver.tk.C &#123;</span><br><span class="line">			receiver.c &lt;- <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *ERateLimiter)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	receiver.tk.Stop()</span><br><span class="line">	<span class="built_in">close</span>(receiver.c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *ERateLimiter)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-receiver.c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestERateLimiter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	limiter := NewERateLimiter(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		limiter.Wait()</span><br><span class="line">		fmt.Println(i+<span class="number">1</span>, NowTimeStr())</span><br><span class="line">	&#125;</span><br><span class="line">	limiter.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="测试输出"><a href="#测试输出" class="headerlink" title="测试输出"></a>测试输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestERateLimiter</span><br><span class="line">1 2021-02-19 11:56:48</span><br><span class="line">2 2021-02-19 11:56:48</span><br><span class="line">3 2021-02-19 11:56:48</span><br><span class="line">4 2021-02-19 11:56:48</span><br><span class="line">5 2021-02-19 11:56:48</span><br><span class="line">6 2021-02-19 11:56:48</span><br><span class="line">7 2021-02-19 11:56:48</span><br><span class="line">8 2021-02-19 11:56:48</span><br><span class="line">9 2021-02-19 11:56:48</span><br><span class="line">10 2021-02-19 11:56:48</span><br><span class="line">11 2021-02-19 11:56:48</span><br><span class="line">12 2021-02-19 11:56:48</span><br><span class="line">13 2021-02-19 11:56:48</span><br><span class="line">14 2021-02-19 11:56:48</span><br><span class="line">15 2021-02-19 11:56:48</span><br><span class="line">16 2021-02-19 11:56:48</span><br><span class="line">17 2021-02-19 11:56:48</span><br><span class="line">18 2021-02-19 11:56:49</span><br><span class="line">19 2021-02-19 11:56:49</span><br><span class="line">20 2021-02-19 11:56:49</span><br><span class="line">21 2021-02-19 11:56:49</span><br><span class="line">22 2021-02-19 11:56:49</span><br><span class="line">23 2021-02-19 11:56:49</span><br><span class="line">24 2021-02-19 11:56:49</span><br><span class="line">25 2021-02-19 11:56:49</span><br><span class="line">26 2021-02-19 11:56:49</span><br><span class="line">27 2021-02-19 11:56:49</span><br><span class="line">28 2021-02-19 11:56:50</span><br><span class="line">29 2021-02-19 11:56:50</span><br><span class="line">30 2021-02-19 11:56:50</span><br><span class="line">31 2021-02-19 11:56:50</span><br><span class="line">32 2021-02-19 11:56:50</span><br><span class="line">33 2021-02-19 11:56:50</span><br><span class="line">34 2021-02-19 11:56:50</span><br><span class="line">35 2021-02-19 11:56:50</span><br><span class="line">36 2021-02-19 11:56:50</span><br><span class="line">37 2021-02-19 11:56:50</span><br><span class="line">38 2021-02-19 11:56:51</span><br><span class="line">39 2021-02-19 11:56:51</span><br><span class="line">40 2021-02-19 11:56:51</span><br><span class="line">41 2021-02-19 11:56:51</span><br><span class="line">42 2021-02-19 11:56:51</span><br><span class="line">43 2021-02-19 11:56:51</span><br><span class="line">44 2021-02-19 11:56:51</span><br><span class="line">45 2021-02-19 11:56:51</span><br><span class="line">46 2021-02-19 11:56:51</span><br><span class="line">47 2021-02-19 11:56:51</span><br><span class="line">48 2021-02-19 11:56:52</span><br><span class="line">49 2021-02-19 11:56:52</span><br><span class="line">50 2021-02-19 11:56:52</span><br><span class="line">--- PASS: TestERateLimiter (4.00s)</span><br><span class="line">PASS</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T06:28:47.000Z" title="1/25/2021, 2:28:47 PM">2021-01-25</time>发表</span><span class="level-item"><time dateTime="2021-01-25T06:42:05.259Z" title="1/25/2021, 2:42:05 PM">2021-01-25</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/25/vue-webpacket-externals/">BundleAnalyzer Webpack externals配置,优化chunk-vendor大小,提高初始加载速度</a></h1><div class="content"><blockquote>
<p>调整了很多次终于见到效果 , 发现最根本的问题在于 被external的包是否依赖Vue, 如果依赖就要把Vue先加external </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vue.config.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">&#x27;/saas-manager&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只用加以下节点 , main.js当中不用调整  </span></span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        <span class="comment">// 使用elementui 必须要先中vue(因为elementui依赖vue, 而在html文件中这两个资源也必需写在&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 之前 ),</span></span><br><span class="line">      vue: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;element-ui&#x27;</span>: <span class="string">&#x27;ELEMENT&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更改编译输出的文件名增加hashcode , 以强制浏览器无法缓存, 保证每次修改能及时看到效果   </span></span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.output.filename(<span class="string">&#x27;js/[name].[hash:6].js&#x27;</span>)</span><br><span class="line">    .chunkFilename(<span class="string">&#x27;js/[name].[hash:6].js&#x27;</span>)</span><br><span class="line">    .end();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次yarn serve 新开浏览器显示 BundleAnalyzer(各资源文件大小占比) </span></span><br><span class="line">  config</span><br><span class="line">    .plugin(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line">    .use(BundleAnalyzerPlugin)</span><br><span class="line">    .init(<span class="function">(<span class="params">Plugin</span>) =&gt;</span> <span class="keyword">new</span> Plugin());</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><em>js文件未做任何调整</em> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main.js </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VueAxios <span class="keyword">from</span> <span class="string">&#x27;vue-axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> elementUtils <span class="keyword">from</span> <span class="string">&#x27;vue-element-utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个资料在index.html 中引用csn资源, 以减少打包后的文件大小</span></span><br><span class="line"><span class="comment">// import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span></span><br><span class="line"><span class="comment">// import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI, &#123;</span><br><span class="line">  size: <span class="string">&#x27;small&#x27;</span>,</span><br><span class="line">  zIndex: <span class="number">3000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    // 外部css </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.14.1/theme-chalk/index.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  bootstrap3 会有graph,所以使用bs3   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">// 外部js  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.14.1/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T08:35:51.000Z" title="1/7/2021, 4:35:51 PM">2021-01-07</time>发表</span><span class="level-item"><time dateTime="2021-03-25T03:31:55.746Z" title="3/25/2021, 11:31:55 AM">2021-03-25</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/07/go4-singleflight/">singleflight在并发场景下保护下游业务</a></h1><div class="content"><h3 id="singleflight-使用场景"><a href="#singleflight-使用场景" class="headerlink" title="singleflight 使用场景"></a>singleflight 使用场景</h3><blockquote>
<p>针对同一业务的同一批请求(需自定义缓存的 key),只放一个请求去执行，其他等待结果(和普通缓存还不一样), 可以在不使用缓存的情况下,保护下游业务；</p>
</blockquote>
<blockquote>
<p>这是一条测试修改</p>
</blockquote>
<blockquote>
<p>例如 1：在有缓存的数据读取业务场景中,缓存过期失效时且大并发场景中,瞬间会有大量请求压到数据库,当设置上缓存后才会恢复.但如果去数据库当中查询数据\内存中计算组装\设置缓存等操作耗时稍长,同样会存在很大的风险，瞬间的巨量数据库访问,可能会使数据库异常。</p>
</blockquote>
<blockquote>
<p>例如 1：同上,在无缓存的场景中, 如果一个业务完成处理需要 1s, 100 并发情况下, 这 1s 内都会被到服务器执行,会给服务器造成巨大的压力, 用 singleflight 只会有一个请求被真正处理, 其它的会等 1s(第一个请求处理完成),直接取第一个请求的处理结果 .<br><a target="_blank" rel="noopener" href="https://studygolang.com/articles/11063">golang singleflight 用武之地,杨锡坤 2017-09-17</a>如果每个请求都落到下游服务，通常会导致下游服务瞬时负载升高。如果使用缓存，如何判断当前接口请求的内容需要缓存下来？缓存的过期、更新问题？</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现原理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait() <span class="comment">//其他的请求阻塞</span></span><br><span class="line">        <span class="keyword">return</span> c.val, c.err</span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    c.val, c.err = fn() <span class="comment">//第一个去执行调用</span></span><br><span class="line">    c.wg.Done() <span class="comment">//同一批都返回</span></span><br><span class="line"></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sample</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDoDupSuppress</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g singleflight.Group</span><br><span class="line">	<span class="keyword">var</span> calls <span class="keyword">int32</span></span><br><span class="line">	fn := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;inprocess %d\n&quot;</span>, calls)</span><br><span class="line">		atomic.AddInt32(&amp;calls, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 模拟耗时</span></span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//  回写返回结果</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> n = <span class="number">30</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// n个协程同时调用了g.Do，fn中的逻辑只会被一个协程执行</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;before request %d\n&quot;</span>, j)</span><br><span class="line">			v, err := g.Do(<span class="string">&quot;key&quot;</span>, fn)</span><br><span class="line"></span><br><span class="line">			fmt.Printf(<span class="string">&quot;after  request %d, %#v\n&quot;</span>, j, v)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;Do error: %v\n&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;done calls= %d\n&quot;</span>, calls)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-29T03:02:57.000Z" title="12/29/2020, 11:02:57 AM">2020-12-29</time>发表</span><span class="level-item"><time dateTime="2020-12-29T03:10:33.047Z" title="12/29/2020, 11:10:33 AM">2020-12-29</time>更新</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/29/go3-test/">go test</a></h1><div class="content"><h4 id="使用TestMain-或自定义Test-为测试增加前置-后置方法调用"><a href="#使用TestMain-或自定义Test-为测试增加前置-后置方法调用" class="headerlink" title="使用TestMain 或自定义Test* 为测试增加前置\后置方法调用"></a>使用TestMain 或自定义Test* 为测试增加前置\后置方法调用</h4><ul>
<li>自定义testFun1, testFun2..方法 , test的t是小写, 这样不会被默认调用</li>
<li>自定义Test*方法, Test的T 大写, 这样可以被go test 工具识别</li>
<li>在Test*方法中按顺序 编写 t.Run(&quot;fun_name&quot;, fun)</li>
<li>编写TestMain方法 , 调用beforeInit, m.Run()(会调用其它Test*方法) afterClear<blockquote>
<p>不写TestMain方法, 直接在 Test*方法中调用也一样,<br>有TestMain方法时, go test 只会识别 TestMain, 所以要显示调用 m.Run() 来调用其它测试方法 </p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmd.go  (写在一个文件中方法读代码)</span></span><br><span class="line"><span class="comment">// 待测试方法,</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExecShell</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, s)</span><br><span class="line">	<span class="keyword">var</span> out bytes.Buffer</span><br><span class="line">	cmd.Stdout = &amp;out</span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testExecShell</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;testExecShell&quot;</span>)</span><br><span class="line">	_, err := ExecShell(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFun1</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;testFun1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beforeInit</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;beforeInit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">afterClear</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;afterClear&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAll</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	t.Run(<span class="string">&quot;testExec..&quot;</span>, testExecShell)</span><br><span class="line">	t.Run(<span class="string">&quot;testfun1&quot;</span>, testFun1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在测试中增加前置/后置函数调用的方法, 思路: 自定义测试的新入口,</span></span><br><span class="line"><span class="comment">// 1 自定义testFun1, testFun2..方法 , test的t是小写, 这样不会被默认调用</span></span><br><span class="line"><span class="comment">// 2 自定义Test*方法, Test的T 大写, 这样可以被go test 工具识别</span></span><br><span class="line"><span class="comment">// 3 在Test*方法中按顺序 编写 t.Run(&quot;fun_name&quot;, fun)</span></span><br><span class="line"><span class="comment">// 4 编写TestMain 方法 , 调用beforeInit, m.Run()(会调用其它Test*方法) afterClear</span></span><br><span class="line"><span class="comment">// 当前不写TestMain方法, 直接在 Test*方法中调用也一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TestMain&quot;</span>)</span><br><span class="line">	beforeInit()</span><br><span class="line">	m.Run()</span><br><span class="line">	afterClear()</span><br><span class="line">	<span class="comment">//m.Run()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; go test -v </span><br><span class="line">---------------------</span><br><span class="line">    TestMain</span><br><span class="line">beforeInit</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAll</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAll&#x2F;testExec..</span><br><span class="line">    cmd_test.go:25: testExecShell</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestAll&#x2F;testfun1</span><br><span class="line">    cmd_test.go:33: testFun1</span><br><span class="line">--- PASS: TestAll (0.01s)</span><br><span class="line">    --- PASS: TestAll&#x2F;testExec.. (0.01s)</span><br><span class="line">    --- PASS: TestAll&#x2F;testfun1 (0.00s)</span><br><span class="line">PASS</span><br><span class="line">afterClear</span><br><span class="line">ok      com.huoli.saas-manager&#x2F;src&#x2F;common&#x2F;util&#x2F;test     0.022s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/5212221?s=460&amp;u=f890915eaab9ebc926b07b5b13749673e7a4cf0b&amp;v=4" alt="zhangxiaodel"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zhangxiaodel</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">20</p></a></div></div></nav></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-22T10:34:55.000Z">2021-02-22</time></p><p class="title"><a href="/2021/02/22/go6-effectivego/">effective go 简读</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-19T03:52:10.000Z">2021-02-19</time></p><p class="title"><a href="/2021/02/19/go5-easylimiter/">简单方法限流实现-利用缓存通道写满时写阻塞, 为空时读阻塞的特性</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-25T06:28:47.000Z">2021-01-25</time></p><p class="title"><a href="/2021/01/25/vue-webpacket-externals/">BundleAnalyzer Webpack externals配置,优化chunk-vendor大小,提高初始加载速度</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-07T08:35:51.000Z">2021-01-07</time></p><p class="title"><a href="/2021/01/07/go4-singleflight/">singleflight在并发场景下保护下游业务</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-29T03:02:57.000Z">2020-12-29</time></p><p class="title"><a href="/2020/12/29/go3-test/">go test</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BundleAnalyzer-Webpack-externals-chunk-vendor/"><span class="tag">BundleAnalyzer,  Webpack externals, chunk-vendor</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/celery-flower-redis/"><span class="tag">celery ,  flower , redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dict-hash/"><span class="tag">dict, hash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/effective-go%E9%A2%84%E8%A7%88/"><span class="tag">effective, go预览</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flask-request/"><span class="tag">flask, request</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go-test-TestMain/"><span class="tag">go test TestMain</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/goroutine-go-pool-%E5%B9%B6%E5%8F%91-%E5%8D%8F%E7%A8%8B/"><span class="tag">goroutine go pool 并发 协程</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json-partial/"><span class="tag">json ,  partial</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/limiter-ratelimiter/"><span class="tag">limiter, ratelimiter</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pr-pull-request/"><span class="tag">pr, pull request</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pyenv-python3-6-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"><span class="tag">pyenv, python3.6 ,虚拟环境</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pytest-mock/"><span class="tag">pytest, mock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python3-7-virtualenv-bz2/"><span class="tag">python3.7, virtualenv , bz2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/singleflight-goroutine/"><span class="tag">singleflight goroutine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sqlalchemy-orm/"><span class="tag">sqlalchemy, orm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vuejs-class/"><span class="tag">vuejs, class</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web-csrf-xss/"><span class="tag">web, csrf ,xss</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web-flask-jsonify/"><span class="tag">web, flask ,jsonify</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web-flask-token/"><span class="tag">web, flask ,token</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%A4%87%E4%BB%BD/"><span class="tag">数据库,备份</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">run coder</a><p class="is-size-7"><span>&copy; 2021 zhangxiaodel</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>